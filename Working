// main.ts - Enhanced Viwoods Notes Importer Plugin for Obsidian with PDF & SVG Rendering

import {
    App,
    Plugin,
    PluginSettingTab,
    Setting,
    Notice,
    TFile,
    TFolder,
    normalizePath,
    Modal,
    MarkdownView,
    MarkdownPostProcessorContext
} from 'obsidian';

declare global {
    interface Window {
        JSZip: any;
        jspdf: any;
    }
}

// ============================================================================
// INTERFACES AND TYPES
// ============================================================================

interface ImportManifest {
    bookName: string;
    totalPages: number;
    importedPages: {
        [pageNumber: number]: {
            fileName: string;
            importDate: string;
            imageHash: string;
            displayImageHash?: string;
            geminiProcessed: boolean;
            hasAudio?: boolean;
            lastModified?: string;
            size?: number;
            backgroundColor?: string;
        }
    };
    lastImport: string;
    sourceFile: string;
    version: string;
    history?: ImportHistory[];
}

interface ImportHistory {
    date: string;
    action: 'import' | 'update' | 'delete';
    pages: number[];
    summary: string;
}

interface PageData {
    pageNum: number;
    image: {
        blob: Blob;
        hash: string;
    };
    stroke?: any;
    audio?: {
        blob: Blob;
        originalName: string;
        name: string;
    };
}

interface BookResult {
    bookName: string;
    metadata: any;
    pages: PageData[];
    thumbnail: Blob | null;
}

interface PageChange {
    pageNum: number;
    type: 'new' | 'modified' | 'unchanged' | 'deleted';
    oldHash?: string;
    newHash?: string;
    hasAudioChange?: boolean;
}

interface ImportSummary {
    totalPages: number;
    newPages: number[];
    modifiedPages: number[];
    unchangedPages: number[];
    deletedPages: number[];
    errors: { page: number; error: string }[];
}

interface ViwoodsSettings {
    notesFolder: string;
    imagesFolder: string;
    audioFolder: string;
    strokesFolder: string;
    pdfFolder: string;
    outputFormat: 'png' | 'svg' | 'both';
    backgroundColor: string;
    includeMetadata: boolean;
    includeTimestamps: boolean;
    includeThumbnails: boolean;
    createIndex: boolean;
    dateFormat: 'iso' | 'us' | 'eu';
    filePrefix: string;
    processWithGemini: boolean;
    organizationMode: 'flat' | 'book';
    skipDuplicates: boolean;
    overwriteExisting: boolean;
    createBackups: boolean;
    batchSize: number;
    enableProgressBar: boolean;
    autoDetectChanges: boolean;
    keepHistory: boolean;
    maxHistoryEntries: number;
    enablePdfExport: boolean;
    enableSvgViewer: boolean;
    defaultSmoothness: number;
    defaultSvgWidth: number;
    autoCreatePDF: boolean;
    showSvgViewer: boolean;
    defaultReplaySpeed: number;
    autoCreatePdfOnImport: boolean;
}

const DEFAULT_SETTINGS: ViwoodsSettings = {
    notesFolder: 'Viwoods Notes',
    imagesFolder: 'Images',
    audioFolder: 'Audio',
    strokesFolder: 'Strokes',
    pdfFolder: 'Attachments/PDF',
    outputFormat: 'png',
    backgroundColor: '#FFFFFF',
    includeMetadata: true,
    includeTimestamps: true,
    includeThumbnails: false,
    createIndex: true,
    dateFormat: 'iso',
    filePrefix: '',
    processWithGemini: false,
    organizationMode: 'book',
    skipDuplicates: true,
    overwriteExisting: false,
    createBackups: true,
    batchSize: 10,
    enableProgressBar: true,
    autoDetectChanges: true,
    keepHistory: true,
    maxHistoryEntries: 50,
    enablePdfExport: true,
    enableSvgViewer: true,
    defaultSmoothness: 0,
    defaultSvgWidth: 100,
    autoCreatePDF: false,
    showSvgViewer: true,
    defaultReplaySpeed: 10,
    autoCreatePdfOnImport: true
};

interface PenMapping {
    type: string;
    color: string;
    thickness: string;
    opacity: number;
}

interface PenMappings {
    [penId: number]: PenMapping;
}

// ============================================================================
// MODAL CLASSES
// ============================================================================

class EnhancedImportModal extends Modal {
    bookResult: BookResult;
    existingManifest: ImportManifest | null;
    analysis: { changes: PageChange[], summary: ImportSummary } | null;
    settings: ViwoodsSettings;
    onChoose: (pages: number[]) => void;
    checkboxes: Map<number, HTMLInputElement> = new Map();
    
    constructor(
        app: App, 
        bookResult: BookResult, 
        existingManifest: ImportManifest | null,
        analysis: { changes: PageChange[], summary: ImportSummary } | null,
        settings: ViwoodsSettings
    ) {
        super(app);
        this.bookResult = bookResult;
        this.existingManifest = existingManifest;
        this.analysis = analysis;
        this.settings = settings;
        this.onChoose = () => {};
    }
    
    onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.classList.add('viwoods-import-modal');
        this.titleEl.setText(`Import: ${this.bookResult.bookName}`);
        
        if (this.analysis) {
            const analysisDiv = contentEl.createDiv({ cls: 'import-analysis' });
            analysisDiv.style.cssText = 'padding: 15px; background: var(--background-secondary); border-radius: 8px; margin-bottom: 15px;';
            analysisDiv.innerHTML = `
                <h3>üìä Change Analysis</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px;">
                    <div>üÜï New pages: <strong>${this.analysis.summary.newPages.length}</strong></div>
                    <div>üîÑ Modified pages: <strong>${this.analysis.summary.modifiedPages.length}</strong></div>
                    <div>‚úì Unchanged pages: <strong>${this.analysis.summary.unchangedPages.length}</strong></div>
                    <div>‚ùå Deleted pages: <strong>${this.analysis.summary.deletedPages.length}</strong></div>
                </div>
            `;
            if (this.analysis.summary.deletedPages.length > 0) {
                analysisDiv.createEl('p', {
                    text: `‚ö†Ô∏è Note: ${this.analysis.summary.deletedPages.length} pages exist locally but not in this import file.`,
                    cls: 'mod-warning'
                });
            }
        } else {
            const stats = contentEl.createDiv({ cls: 'import-stats' });
            stats.style.cssText = 'padding: 15px; background: var(--background-secondary); border-radius: 8px; margin-bottom: 15px;';
            const existingPages = this.existingManifest ? Object.keys(this.existingManifest.importedPages).length : 0;
            stats.innerHTML = `
                <h3>üìö ${this.bookResult.bookName}</h3>
                <p>üìÑ Total pages in file: ${this.bookResult.pages.length}</p>
                <p>‚úÖ Already imported: ${existingPages}</p>
                <p>üéôÔ∏è Pages with audio: ${this.bookResult.pages.filter(p => p.audio).length}</p>
            `;
        }
        
        const modeContainer = contentEl.createDiv();
        modeContainer.createEl('label', { text: 'Import mode:' });
        const importMode = modeContainer.createEl('select', { cls: 'dropdown' }) as HTMLSelectElement;
        importMode.style.cssText = 'width: 100%; margin: 10px 0;';
        
        let defaultMode = 'all';
        if (this.analysis) {
            const hasNew = this.analysis.summary.newPages.length > 0;
            const hasModified = this.analysis.summary.modifiedPages.length > 0;
            if (hasNew && hasModified) defaultMode = 'new-and-modified';
            else if (hasNew) defaultMode = 'new';
            else if (hasModified) defaultMode = 'modified';
            else defaultMode = 'none';
        }
        
        if (this.analysis && this.analysis.summary.newPages.length > 0) {
            const option = importMode.createEl('option', { value: 'new', text: `Import new pages only (${this.analysis.summary.newPages.length} pages)` });
            if (defaultMode === 'new') option.selected = true;
        }
        if (this.analysis && this.analysis.summary.modifiedPages.length > 0) {
            const option = importMode.createEl('option', { value: 'modified', text: `Import modified pages only (${this.analysis.summary.modifiedPages.length} pages)` });
            if (defaultMode === 'modified') option.selected = true;
        }
        if (this.analysis && (this.analysis.summary.newPages.length > 0 || this.analysis.summary.modifiedPages.length > 0)) {
            const option = importMode.createEl('option', { value: 'new-and-modified', text: `Import new & modified pages (${this.analysis.summary.newPages.length + this.analysis.summary.modifiedPages.length} pages)` });
            if (defaultMode === 'new-and-modified') option.selected = true;
        }
        
        const allOption = importMode.createEl('option', { value: 'all', text: `Import all pages (${this.bookResult.pages.length} pages)` });
        if (!this.existingManifest || (defaultMode === 'all' && importMode.options.length === 1)) allOption.selected = true;
        
        importMode.createEl('option', { value: 'range', text: 'Import page range...' });
        importMode.createEl('option', { value: 'select', text: 'Select specific pages...' });
        
        if (defaultMode === 'none' && this.analysis) {
            const noneOption = importMode.createEl('option', { value: 'none', text: 'No changes to import' });
            noneOption.selected = true;
        }
        
        const rangeContainer = contentEl.createDiv();
        rangeContainer.style.cssText = 'display: none; margin: 10px 0;';
        rangeContainer.createEl('label', { text: 'Page range: ' });
        const rangeFrom = rangeContainer.createEl('input', { type: 'number' }) as HTMLInputElement;
        rangeFrom.style.cssText = 'width: 60px;';
        rangeFrom.min = '1';
        rangeFrom.max = this.bookResult.pages.length.toString();
        rangeFrom.value = '1';
        rangeContainer.createEl('span', { text: ' to ' });
        const rangeTo = rangeContainer.createEl('input', { type: 'number' }) as HTMLInputElement;
        rangeTo.style.cssText = 'width: 60px;';
        rangeTo.min = '1';
        rangeTo.max = this.bookResult.pages.length.toString();
        rangeTo.value = Math.min(10, this.bookResult.pages.length).toString();
        
        const pageSelector = contentEl.createDiv();
        pageSelector.style.display = 'none';
        pageSelector.createEl('p', { text: 'Select pages to import:' });
        
        const searchContainer = pageSelector.createDiv();
        searchContainer.style.cssText = 'margin: 10px 0;';
        const searchInput = searchContainer.createEl('input', { type: 'text', placeholder: 'Search pages (e.g., "1-10", "audio", "new")...' }) as HTMLInputElement;
        searchInput.style.cssText = 'width: 100%; padding: 5px;';
        
        const filterButtons = pageSelector.createDiv();
        filterButtons.style.cssText = 'margin: 10px 0; display: flex; gap: 5px; flex-wrap: wrap;';
        const selectAllBtn = filterButtons.createEl('button', { text: 'Select All' });
        const selectNoneBtn = filterButtons.createEl('button', { text: 'Select None' });
        const selectNewBtn = filterButtons.createEl('button', { text: 'Select New' });
        const selectModifiedBtn = filterButtons.createEl('button', { text: 'Select Modified' });
        const selectAudioBtn = filterButtons.createEl('button', { text: 'Select Audio' });
        
        const pageGrid = pageSelector.createDiv();
        pageGrid.style.cssText = 'display: grid; grid-template-columns: repeat(10, 1fr); gap: 5px; max-height: 300px; overflow-y: auto; padding: 10px; background: var(--background-primary); border-radius: 5px;';
        
        for (const page of this.bookResult.pages) {
            const pageDiv = pageGrid.createDiv();
            pageDiv.style.cssText = 'text-align: center; padding: 5px;';
            const change = this.analysis?.changes.find(c => c.pageNum === page.pageNum);
            const checkbox = pageDiv.createEl('input', { type: 'checkbox' }) as HTMLInputElement;
            checkbox.id = `page-${page.pageNum}`;
            checkbox.checked = change?.type === 'new' || change?.type === 'modified' || false;
            this.checkboxes.set(page.pageNum, checkbox);
            const label = pageDiv.createEl('label');
            label.setAttribute('for', `page-${page.pageNum}`);
            label.style.cssText = 'display: block; font-size: 11px; cursor: pointer;';
            let labelText = `${page.pageNum}`;
            if (page.audio) labelText += 'üéôÔ∏è';
            if (change) {
                switch (change.type) {
                    case 'new': labelText += 'üÜï'; label.style.color = 'var(--text-accent)'; break;
                    case 'modified': labelText += 'üîÑ'; label.style.color = 'var(--text-warning)'; break;
                    case 'unchanged': labelText += '‚úì'; label.style.opacity = '0.6'; break;
                }
            }
            label.textContent = labelText;
            pageDiv.dataset.pageNum = page.pageNum.toString();
            pageDiv.dataset.hasAudio = page.audio ? 'true' : 'false';
            if (change) pageDiv.dataset.changeType = change.type;
        }
        
        searchInput.addEventListener('input', (e) => {
            const query = (e.target as HTMLInputElement).value.toLowerCase();
            this.checkboxes.forEach((checkbox, pageNum) => {
                const pageDiv = checkbox.parentElement;
                if (!pageDiv) return;
                let visible = false;
                if (pageNum.toString().includes(query)) visible = true;
                const rangeMatch = query.match(/(\d+)-(\d+)/);
                if (rangeMatch) {
                    const start = parseInt(rangeMatch[1]);
                    const end = parseInt(rangeMatch[2]);
                    if (pageNum >= start && pageNum <= end) visible = true;
                }
                if (query.includes('audio') && pageDiv.dataset.hasAudio === 'true') visible = true;
                if (query.includes('new') && pageDiv.dataset.changeType === 'new') visible = true;
                if (query.includes('modified') && pageDiv.dataset.changeType === 'modified') visible = true;
                (pageDiv as HTMLElement).style.display = visible || query === '' ? 'block' : 'none';
            });
        });
        
        selectAllBtn.onclick = () => this.checkboxes.forEach(cb => cb.checked = true);
        selectNoneBtn.onclick = () => this.checkboxes.forEach(cb => cb.checked = false);
        selectNewBtn.onclick = () => {
            this.checkboxes.forEach((cb, pageNum) => {
                const change = this.analysis?.changes.find(c => c.pageNum === pageNum);
                cb.checked = change?.type === 'new' || false;
            });
        };
        selectModifiedBtn.onclick = () => {
            this.checkboxes.forEach((cb, pageNum) => {
                const change = this.analysis?.changes.find(c => c.pageNum === pageNum);
                cb.checked = change?.type === 'modified' || false;
            });
        };
        selectAudioBtn.onclick = () => {
            this.checkboxes.forEach((cb, pageNum) => {
                const page = this.bookResult.pages.find(p => p.pageNum === pageNum);
                cb.checked = !!page?.audio;
            });
        };
        
        importMode.addEventListener('change', () => {
            rangeContainer.style.display = importMode.value === 'range' ? 'block' : 'none';
            pageSelector.style.display = importMode.value === 'select' ? 'block' : 'none';
        });
        
        const buttonContainer = contentEl.createDiv();
        buttonContainer.style.cssText = 'display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;';
        const cancelBtn = buttonContainer.createEl('button', { text: 'Cancel' });
        const importBtn = buttonContainer.createEl('button', { text: 'Import', cls: 'mod-cta' });
        
        importBtn.onclick = () => {
            let pagesToImport: number[] = [];
            switch (importMode.value) {
                case 'new': pagesToImport = this.analysis?.summary.newPages || []; break;
                case 'modified': pagesToImport = this.analysis?.summary.modifiedPages || []; break;
                case 'new-and-modified': pagesToImport = [...(this.analysis?.summary.newPages || []), ...(this.analysis?.summary.modifiedPages || [])]; break;
                case 'all': pagesToImport = this.bookResult.pages.map(p => p.pageNum); break;
                case 'range':
                    const from = parseInt(rangeFrom.value);
                    const to = parseInt(rangeTo.value);
                    for (let i = from; i <= to && i <= this.bookResult.pages.length; i++) pagesToImport.push(i);
                    break;
                case 'select':
                    this.checkboxes.forEach((checkbox, pageNum) => { if (checkbox.checked) pagesToImport.push(pageNum); });
                    break;
                case 'none': break;
            }
            this.close();
            this.onChoose(pagesToImport);
        };
        cancelBtn.onclick = () => { this.close(); this.onChoose([]); };
    }
}

class ProgressModal extends Modal {
    progressBar: HTMLProgressElement;
    statusText: HTMLElement;
    totalPages: number;
    
    constructor(app: App, totalPages: number) {
        super(app);
        this.totalPages = totalPages;
    }
    
    onOpen() {
        const { contentEl } = this;
        contentEl.createEl('h2', { text: 'Importing Pages' });
        this.statusText = contentEl.createEl('p', { text: 'Starting import...' });
        this.progressBar = contentEl.createEl('progress') as HTMLProgressElement;
        this.progressBar.style.cssText = 'width: 100%; height: 20px;';
        this.progressBar.max = this.totalPages;
        this.progressBar.value = 0;
        const progressText = contentEl.createDiv();
        progressText.style.cssText = 'text-align: center; margin-top: 10px;';
        progressText.textContent = `0 / ${this.totalPages}`;
    }
    
    updateProgress(current: number, message: string) {
        if (!this.progressBar) return;
        this.progressBar.value = current;
        this.statusText.textContent = message;
        const progressText = this.contentEl.querySelector('div');
        if (progressText) progressText.textContent = `${current} / ${this.totalPages}`;
    }
}

class ImportSummaryModal extends Modal {
    summary: ImportSummary;
    backupPath: string | null;
    
    constructor(app: App, summary: ImportSummary, backupPath: string | null) {
        super(app);
        this.summary = summary;
        this.backupPath = backupPath;
    }
    
    onOpen() {
        const { contentEl } = this;
        contentEl.createEl('h2', { text: 'Import Complete' });
        const summaryDiv = contentEl.createDiv({ cls: 'import-summary' });
        summaryDiv.style.cssText = 'padding: 15px; background: var(--background-secondary); border-radius: 8px;';
        let summaryHTML = '<h3>üìä Import Summary</h3><div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px;">';
        if (this.summary.newPages.length > 0) summaryHTML += `<div>üÜï New pages: <strong>${this.summary.newPages.length}</strong></div>`;
        if (this.summary.modifiedPages.length > 0) summaryHTML += `<div>üîÑ Modified pages: <strong>${this.summary.modifiedPages.length}</strong></div>`;
        if (this.summary.unchangedPages.length > 0) summaryHTML += `<div>‚úì Unchanged pages: <strong>${this.summary.unchangedPages.length}</strong></div>`;
        if (this.summary.errors.length > 0) summaryHTML += `<div style="color: var(--text-error);">‚ùå Errors: <strong>${this.summary.errors.length}</strong></div>`;
        summaryHTML += '</div>';
        summaryDiv.innerHTML = summaryHTML;
        
        if (this.summary.errors.length > 0) {
            const errorDiv = contentEl.createDiv({ cls: 'import-errors' });
            errorDiv.style.cssText = 'margin-top: 15px; padding: 10px; background: var(--background-secondary-alt); border-radius: 5px;';
            errorDiv.createEl('h4', { text: 'Import Errors:' });
            const errorList = errorDiv.createEl('ul');
            this.summary.errors.forEach(error => errorList.createEl('li', { text: `Page ${error.page}: ${error.error}` }));
        }
        
        if (this.backupPath) {
            const backupDiv = contentEl.createDiv();
            backupDiv.style.cssText = 'margin-top: 15px; padding: 10px; background: var(--background-modifier-success); border-radius: 5px;';
            backupDiv.createEl('p', { text: `‚úÖ Manifest backup created: ${this.backupPath.split('/').pop()}` });
        }
        
        const buttonDiv = contentEl.createDiv();
        buttonDiv.style.cssText = 'display: flex; justify-content: center; margin-top: 20px;';
        const okBtn = buttonDiv.createEl('button', { text: 'OK', cls: 'mod-cta' });
        okBtn.onclick = () => this.close();
    }
}

class ExportModal extends Modal {
    plugin: ViwoodsImporterPlugin;
    
    constructor(app: App, plugin: ViwoodsImporterPlugin) {
        super(app);
        this.plugin = plugin;
    }
    
    onOpen() {
        const { contentEl } = this;
        contentEl.createEl('h2', { text: 'Export Viwoods Book' });
        contentEl.createEl('p', { text: 'Select a book and export format. This will create a package with all pages and media.' });
        
        const bookSelect = contentEl.createEl('select', { cls: 'dropdown' }) as HTMLSelectElement;
        bookSelect.style.cssText = 'width: 100%; margin: 10px 0;';
        const booksFolder = this.app.vault.getAbstractFileByPath(this.plugin.settings.notesFolder);
        if (booksFolder instanceof TFolder) {
            for (const child of booksFolder.children) {
                if (child instanceof TFolder) bookSelect.createEl('option', { value: child.path, text: child.name });
            }
        }
        
        const formatLabel = contentEl.createEl('label', { text: 'Export format:' });
        const formatSelect = contentEl.createEl('select', { cls: 'dropdown' }) as HTMLSelectElement;
        formatSelect.style.cssText = 'width: 100%; margin: 10px 0;';
        formatSelect.createEl('option', { value: 'markdown', text: 'Markdown with media (ZIP)' });
        formatSelect.createEl('option', { value: 'pdf', text: 'PDF (single file)' });
        formatSelect.createEl('option', { value: 'html', text: 'HTML (standalone)' });
        
        const optionsDiv = contentEl.createDiv();
        optionsDiv.style.cssText = 'margin: 15px 0;';
        const includeAudioCheck = optionsDiv.createEl('input', { type: 'checkbox' }) as HTMLInputElement;
        includeAudioCheck.id = 'include-audio';
        includeAudioCheck.checked = true;
        const includeAudioLabel = optionsDiv.createEl('label');
        includeAudioLabel.setAttribute('for', 'include-audio');
        includeAudioLabel.textContent = ' Include audio recordings';
        optionsDiv.createEl('br');
        const includeGeminiCheck = optionsDiv.createEl('input', { type: 'checkbox' }) as HTMLInputElement;
        includeGeminiCheck.id = 'include-gemini';
        includeGeminiCheck.checked = true;
        const includeGeminiLabel = optionsDiv.createEl('label');
        includeGeminiLabel.setAttribute('for', 'include-gemini');
        includeGeminiLabel.textContent = ' Include Gemini transcriptions';
        
        const buttonDiv = contentEl.createDiv();
        buttonDiv.style.cssText = 'display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px;';
        const cancelBtn = buttonDiv.createEl('button', { text: 'Cancel' });
        const exportBtn = buttonDiv.createEl('button', { text: 'Export', cls: 'mod-cta' });
        
        exportBtn.onclick = async () => {
            const bookPath = bookSelect.value;
            const format = formatSelect.value;
            const includeAudio = includeAudioCheck.checked;
            const includeGemini = includeGeminiCheck.checked;
            this.close();
            try {
                await this.exportBook(bookPath, format as any, includeAudio, includeGemini);
                new Notice('Export completed successfully!');
            } catch (error: any) {
                console.error('Export failed:', error);
                new Notice('Export failed: ' + error.message);
            }
        };
        cancelBtn.onclick = () => this.close();
    }
    
    async exportBook(bookPath: string, format: 'markdown' | 'pdf' | 'html', includeAudio: boolean, includeGemini: boolean) {
        new Notice(`Export functionality for ${format} format would be implemented here`);
    }
}

class ImportModal extends Modal {
    plugin: ViwoodsImporterPlugin;
    fileInput: HTMLInputElement;

    constructor(app: App, plugin: ViwoodsImporterPlugin) {
        super(app);
        this.plugin = plugin;
    }

    onOpen() {
        const { contentEl } = this;
        contentEl.createEl('h2', { text: 'Import Viwoods Note' });
        contentEl.createEl('p', { text: 'Select .note files to import. Each file may contain multiple pages that will be organized into a book structure.' });
        
        const recentDiv = contentEl.createDiv();
        recentDiv.style.cssText = 'margin: 15px 0; padding: 10px; background: var(--background-secondary); border-radius: 5px;';
        recentDiv.createEl('h3', { text: 'Recent Books' });
        
        const booksFolder = this.app.vault.getAbstractFileByPath(this.plugin.settings.notesFolder);
        if (booksFolder instanceof TFolder) {
            const recentBooks = booksFolder.children.filter(child => child instanceof TFolder).slice(0, 5);
            if (recentBooks.length > 0) {
                const bookList = recentDiv.createEl('ul');
                bookList.style.cssText = 'list-style: none; padding: 0;';
                for (const book of recentBooks) {
                    const li = bookList.createEl('li');
                    li.style.cssText = 'padding: 3px 0;';
                    li.textContent = `üìö ${book.name}`;
                }
            } else {
                recentDiv.createEl('p', { text: 'No books imported yet.', cls: 'mod-muted' });
            }
        }
        
        contentEl.createEl('h3', { text: 'Select Files' });
        this.fileInput = contentEl.createEl('input', { type: 'file', attr: { multiple: true, accept: '.note,.zip' } }) as HTMLInputElement;
        this.fileInput.style.marginBottom = '20px';
        
        const dropArea = contentEl.createDiv({ cls: 'drop-area' });
        dropArea.style.cssText = 'border: 2px dashed var(--background-modifier-border); border-radius: 8px; padding: 30px; text-align: center; margin: 15px 0;';
        dropArea.createEl('p', { text: 'üì• Drag and drop .note files here' });
        
        dropArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropArea.style.borderColor = 'var(--interactive-accent)';
        });
        dropArea.addEventListener('dragleave', () => {
            dropArea.style.borderColor = 'var(--background-modifier-border)';
        });
        dropArea.addEventListener('drop', async (e) => {
            e.preventDefault();
            dropArea.style.borderColor = 'var(--background-modifier-border)';
            const files = Array.from(e.dataTransfer?.files || []).filter(f => f.name.endsWith('.note') || f.name.endsWith('.zip'));
            if (files.length > 0) {
                this.close();
                for (const file of files) await this.plugin.processNoteFile(file);
            }
        });
        
        const buttonDiv = contentEl.createDiv();
        buttonDiv.style.cssText = 'display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px;';
        const cancelBtn = buttonDiv.createEl('button', { text: 'Cancel' });
        const importBtn = buttonDiv.createEl('button', { text: 'Import', cls: 'mod-cta' });
        
        importBtn.addEventListener('click', async () => {
            const files = Array.from(this.fileInput.files || []);
            if (files.length > 0) {
                this.close();
                for (const file of files) await this.plugin.processNoteFile(file);
            } else {
                new Notice('Please select files to import');
            }
        });
        cancelBtn.addEventListener('click', () => this.close());
    }

    onClose() {
        const { contentEl } = this;
        contentEl.empty();
    }
}

class ViwoodsSettingTab extends PluginSettingTab {
    plugin: ViwoodsImporterPlugin;

    constructor(app: App, plugin: ViwoodsImporterPlugin) {
        super(app, plugin);
        this.plugin = plugin;
    }

    display(): void {
        const { containerEl } = this;
        containerEl.empty();
        containerEl.createEl('h2', { text: 'Viwoods Notes Importer Settings' });

        containerEl.createEl('h3', { text: 'Organization' });
        new Setting(containerEl).setName('Organization mode').setDesc('How to organize imported notes').addDropdown(dropdown => dropdown
            .addOption('book', 'Book mode (recommended) - One folder per notebook').addOption('flat', 'Flat mode - All pages in one folder')
            .setValue(this.plugin.settings.organizationMode).onChange(async (value: 'book' | 'flat') => {
                this.plugin.settings.organizationMode = value;
                await this.plugin.saveSettings();
            }));
        new Setting(containerEl).setName('Create index').setDesc('Create an index file for each book with links to all pages').addToggle(toggle => toggle
            .setValue(this.plugin.settings.createIndex).onChange(async (value) => {
                this.plugin.settings.createIndex = value;
                await this.plugin.saveSettings();
            }));

        containerEl.createEl('h3', { text: 'Import Behavior' });
        new Setting(containerEl).setName('Auto-detect changes').setDesc('Automatically detect new, modified, and unchanged pages during import').addToggle(toggle => toggle
            .setValue(this.plugin.settings.autoDetectChanges).onChange(async (value) => {
                this.plugin.settings.autoDetectChanges = value;
                await this.plugin.saveSettings();
            }));
        new Setting(containerEl).setName('Skip duplicates').setDesc('Skip importing pages that already exist with the same content').addToggle(toggle => toggle
            .setValue(this.plugin.settings.skipDuplicates).onChange(async (value) => {
                this.plugin.settings.skipDuplicates = value;
                await this.plugin.saveSettings();
            }));
        new Setting(containerEl).setName('Overwrite existing').setDesc('Overwrite existing pages when importing (only if skip duplicates is off)').addToggle(toggle => toggle
            .setValue(this.plugin.settings.overwriteExisting).onChange(async (value) => {
                this.plugin.settings.overwriteExisting = value;
                await this.plugin.saveSettings();
            }));
        new Setting(containerEl).setName('Create backups').setDesc('Create backup of manifest before making changes').addToggle(toggle => toggle
            .setValue(this.plugin.settings.createBackups).onChange(async (value) => {
                this.plugin.settings.createBackups = value;
                await this.plugin.saveSettings();
            }));

        containerEl.createEl('h3', { text: 'Performance' });
        new Setting(containerEl).setName('Batch size').setDesc('Number of pages to process simultaneously (higher = faster but more memory)').addSlider(slider => slider
            .setLimits(1, 20, 1).setValue(this.plugin.settings.batchSize).setDynamicTooltip().onChange(async (value) => {
                this.plugin.settings.batchSize = value;
                await this.plugin.saveSettings();
            }));
        new Setting(containerEl).setName('Show progress bar').setDesc('Display progress bar during import').addToggle(toggle => toggle
            .setValue(this.plugin.settings.enableProgressBar).onChange(async (value) => {
                this.plugin.settings.enableProgressBar = value;
                await this.plugin.saveSettings();
            }));

        containerEl.createEl('h3', { text: 'History' });
        new Setting(containerEl).setName('Keep import history').setDesc('Track history of imports and changes').addToggle(toggle => toggle
            .setValue(this.plugin.settings.keepHistory).onChange(async (value) => {
                this.plugin.settings.keepHistory = value;
                await this.plugin.saveSettings();
            }));
        new Setting(containerEl).setName('Maximum history entries').setDesc('Number of history entries to keep per book').addSlider(slider => slider
            .setLimits(10, 100, 10).setValue(this.plugin.settings.maxHistoryEntries).setDynamicTooltip().onChange(async (value) => {
                this.plugin.settings.maxHistoryEntries = value;
                await this.plugin.saveSettings();
            }));

        containerEl.createEl('h3', { text: 'Storage Locations' });
        new Setting(containerEl).setName('Notes folder').setDesc('Root folder for imported notebooks').addText(text => text
            .setPlaceholder('Viwoods Notes').setValue(this.plugin.settings.notesFolder).onChange(async (value) => {
                this.plugin.settings.notesFolder = value;
                await this.plugin.saveSettings();
            }));
        new Setting(containerEl).setName('Images subfolder').setDesc('Subfolder name for images within each book (relative to book folder)').addText(text => text
            .setPlaceholder('Images').setValue(this.plugin.settings.imagesFolder).onChange(async (value) => {
                this.plugin.settings.imagesFolder = value;
                await this.plugin.saveSettings();
            }));
        new Setting(containerEl).setName('Audio subfolder').setDesc('Subfolder name for audio within each book (relative to book folder)').addText(text => text
            .setPlaceholder('Audio').setValue(this.plugin.settings.audioFolder).onChange(async (value) => {
                this.plugin.settings.audioFolder = value;
                await this.plugin.saveSettings();
            }));
        new Setting(containerEl).setName('Strokes subfolder').setDesc('Subfolder name for stroke data JSON files (relative to book folder)').addText(text => text
            .setPlaceholder('Strokes').setValue(this.plugin.settings.strokesFolder).onChange(async (value) => {
                this.plugin.settings.strokesFolder = value;
                await this.plugin.saveSettings();
            }));
        new Setting(containerEl).setName('PDF output folder').setDesc('Folder for auto-generated PDF exports').addText(text => text
            .setPlaceholder('Attachments/PDF').setValue(this.plugin.settings.pdfFolder).onChange(async (value) => {
                this.plugin.settings.pdfFolder = value;
                await this.plugin.saveSettings();
            }));

        containerEl.createEl('h3', { text: 'Output Settings' });
        new Setting(containerEl).setName('Output format').setDesc('Choose how to convert handwritten notes').addDropdown(dropdown => dropdown
            .addOption('png', 'PNG Images').addOption('svg', 'SVG (from strokes)').addOption('both', 'Both PNG and SVG')
            .setValue(this.plugin.settings.outputFormat).onChange(async (value: 'png' | 'svg' | 'both') => {
                this.plugin.settings.outputFormat = value;
                await this.plugin.saveSettings();
            }));
        new Setting(containerEl).setName('Background color').setDesc('Background color for PNG images (hex color or "transparent")').addText(text => text
            .setPlaceholder('#FFFFFF').setValue(this.plugin.settings.backgroundColor).onChange(async (value) => {
                this.plugin.settings.backgroundColor = value;
                await this.plugin.saveSettings();
            }));
        new Setting(containerEl).setName('File prefix').setDesc('Optional prefix for book names').addText(text => text
            .setPlaceholder('viwoods_').setValue(this.plugin.settings.filePrefix).onChange(async (value) => {
                this.plugin.settings.filePrefix = value;
                await this.plugin.saveSettings();
            }));

        containerEl.createEl('h3', { text: 'Metadata Options' });
        new Setting(containerEl).setName('Include metadata').setDesc('Add frontmatter metadata to notes').addToggle(toggle => toggle
            .setValue(this.plugin.settings.includeMetadata).onChange(async (value) => {
                this.plugin.settings.includeMetadata = value;
                await this.plugin.saveSettings();
            }));
        new Setting(containerEl).setName('Include timestamps').setDesc('Add creation and modification dates').addToggle(toggle => toggle
            .setValue(this.plugin.settings.includeTimestamps).onChange(async (value) => {
                this.plugin.settings.includeTimestamps = value;
                await this.plugin.saveSettings();
            }));
        new Setting(containerEl).setName('Include thumbnails').setDesc('Import thumbnail images').addToggle(toggle => toggle
            .setValue(this.plugin.settings.includeThumbnails).onChange(async (value) => {
                this.plugin.settings.includeThumbnails = value;
                await this.plugin.saveSettings();
            }));

        containerEl.createEl('h3', { text: 'SVG and PDF Settings' });
        new Setting(containerEl).setName('Enable PDF Export').setDesc('Allow exporting pages to PDF format').addToggle(toggle => toggle
            .setValue(this.plugin.settings.enablePdfExport).onChange(async (value) => {
                this.plugin.settings.enablePdfExport = value;
                await this.plugin.saveSettings();
            }));
        new Setting(containerEl).setName('Auto-create PDF on import').setDesc('Automatically generate PDF from strokes when importing').addToggle(toggle => toggle
            .setValue(this.plugin.settings.autoCreatePdfOnImport).onChange(async (value) => {
                this.plugin.settings.autoCreatePdfOnImport = value;
                await this.plugin.saveSettings();
            }));
        new Setting(containerEl).setName('Enable SVG Viewer').setDesc('Show interactive SVG viewer in notes').addToggle(toggle => toggle
            .setValue(this.plugin.settings.enableSvgViewer).onChange(async (value) => {
                this.plugin.settings.enableSvgViewer = value;
                await this.plugin.saveSettings();
            }));
        new Setting(containerEl).setName('Show SVG viewer in notes').setDesc('Include SVG viewer block when importing notes').addToggle(toggle => toggle
            .setValue(this.plugin.settings.showSvgViewer).onChange(async (value) => {
                this.plugin.settings.showSvgViewer = value;
                await this.plugin.saveSettings();
            }));
        new Setting(containerEl).setName('Auto-create PDF').setDesc('Automatically create PDF export when viewing strokes').addToggle(toggle => toggle
            .setValue(this.plugin.settings.autoCreatePDF).onChange(async (value) => {
                this.plugin.settings.autoCreatePDF = value;
                await this.plugin.saveSettings();
            }));
        new Setting(containerEl).setName('Default Smoothness').setDesc('Default smoothing factor for SVG strokes (0-20)').addSlider(slider => slider
            .setLimits(0, 20, 1).setValue(this.plugin.settings.defaultSmoothness).setDynamicTooltip().onChange(async (value) => {
                this.plugin.settings.defaultSmoothness = value;
                await this.plugin.saveSettings();
            }));
        new Setting(containerEl).setName('Default SVG Width').setDesc('Default width percentage for SVG viewer (50-100)').addSlider(slider => slider
            .setLimits(50, 100, 10).setValue(this.plugin.settings.defaultSvgWidth).setDynamicTooltip().onChange(async (value) => {
                this.plugin.settings.defaultSvgWidth = value;
                await this.plugin.saveSettings();
            }));
        new Setting(containerEl).setName('Default replay speed').setDesc('Default speed for stroke replay animation (1-50)').addSlider(slider => slider
            .setLimits(1, 50, 1).setValue(this.plugin.settings.defaultReplaySpeed).setDynamicTooltip().onChange(async (value) => {
                this.plugin.settings.defaultReplaySpeed = value;
                await this.plugin.saveSettings();
            }));

        containerEl.createEl('h3', { text: 'Gemini Integration' });
        const app = this.plugin.app as any;
        const isGeminiEnabled = app.plugins?.enabledPlugins?.has('gemini-note-processor');
        if (!isGeminiEnabled) {
            containerEl.createEl('p', { text: '‚ö†Ô∏è Gemini Note Processor plugin is not installed or enabled.', cls: 'setting-item-description mod-warning' });
        } else {
            containerEl.createEl('p', { text: '‚úÖ Gemini Note Processor plugin is ready', cls: 'setting-item-description' });
        }
        new Setting(containerEl).setName('Process with Gemini AI').setDesc('Automatically transcribe handwritten notes using Gemini AI after import').addToggle(toggle => toggle
            .setValue(this.plugin.settings.processWithGemini).onChange(async (value) => {
                this.plugin.settings.processWithGemini = value;
                await this.plugin.saveSettings();
            }));
        new Setting(containerEl).setName('Date format').setDesc('Format for dates in metadata').addDropdown(dropdown => dropdown
            .addOption('iso', 'ISO (YYYY-MM-DD)').addOption('us', 'US (MM/DD/YYYY)').addOption('eu', 'EU (DD/MM/YYYY)')
            .setValue(this.plugin.settings.dateFormat).onChange(async (value: 'iso' | 'us' | 'eu') => {
                this.plugin.settings.dateFormat = value;
                await this.plugin.saveSettings();
            }));
    }
}

// ============================================================================
// MAIN PLUGIN CLASS
// ============================================================================

export default class ViwoodsImporterPlugin extends Plugin {
    settings: ViwoodsSettings;
    importInProgress: boolean = false;
    penMappings: PenMappings = {};

    async onload() {
        await this.loadSettings();
        await this.loadJSZip();
        await this.loadJsPDF();
        await this.loadPenMappings();

        this.addRibbonIcon('import', 'Import Viwoods Note', async () => {
            if (this.importInProgress) {
                new Notice('Import already in progress');
                return;
            }
            new ImportModal(this.app, this).open();
        });

        this.addCommand({
            id: 'import-viwoods-note',
            name: 'Import Viwoods .note file',
            callback: () => {
                if (this.importInProgress) {
                    new Notice('Import already in progress');
                    return;
                }
                new ImportModal(this.app, this).open();
            }
        });

        this.addCommand({
            id: 'export-viwoods-book',
            name: 'Export Viwoods book',
            callback: () => {
                new ExportModal(this.app, this).open();
            }
        });

        this.addCommand({
            id: 'export-page-to-pdf',
            name: 'Export current page to PDF',
            editorCallback: async (editor, view) => {
                const markdownView = view instanceof MarkdownView ? view : this.app.workspace.getActiveViewOfType(MarkdownView);
                if (markdownView) {
                    await this.exportCurrentPageToPDF(markdownView);
                }
            }
        });

        this.addCommand({
            id: 'reset-book-hashes',
            name: 'Reset book hashes (fix change detection)',
            callback: async () => {
                const booksFolder = this.app.vault.getAbstractFileByPath(this.settings.notesFolder);
                if (!(booksFolder instanceof TFolder)) {
                    new Notice('No books found');
                    return;
                }
                const books = booksFolder.children.filter(child => child instanceof TFolder).map(folder => folder.name);
                if (books.length === 0) {
                    new Notice('No books found');
                    return;
                }
                const modal = new Modal(this.app);
                modal.titleEl.setText('Select Book to Reset');
                const select = modal.contentEl.createEl('select');
                books.forEach(book => select.createEl('option', { value: book, text: book }));
                const buttonDiv = modal.contentEl.createDiv();
                buttonDiv.style.cssText = 'margin-top: 20px; text-align: right;';
                const resetBtn = buttonDiv.createEl('button', { text: 'Reset Hashes', cls: 'mod-cta' });
                resetBtn.onclick = async () => {
                    const bookName = select.value;
                    const manifestPath = `${this.settings.notesFolder}/${bookName}/.import-manifest.json`;
                    const manifest = await this.loadManifest(manifestPath);
                    if (manifest) {
                        Object.keys(manifest.importedPages).forEach(pageNum => {
                            manifest.importedPages[parseInt(pageNum)].imageHash = 'RESET-' + Date.now();
                        });
                        await this.saveManifest(manifestPath, manifest);
                        new Notice(`Reset hashes for ${bookName}. Next import will update them.`);
                    } else {
                        new Notice('No manifest found for this book');
                    }
                    modal.close();
                };
                buttonDiv.createEl('button', { text: 'Cancel' }).onclick = () => modal.close();
                modal.open();
            }
        });

        this.registerMarkdownCodeBlockProcessor('viwoods-svg', async (source, el, ctx) => {
            await this.renderSvgViewer(source, el, ctx);
        });

        this.registerDomEvent(document, 'drop', this.handleDrop.bind(this));
        this.registerDomEvent(document, 'dragover', this.handleDragOver.bind(this));

        this.addSettingTab(new ViwoodsSettingTab(this.app, this));
    }

    async loadJSZip() {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
        script.async = true;
        document.head.appendChild(script);
        return new Promise((resolve) => { script.onload = resolve; });
    }

    async loadJsPDF() {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
        script.async = true;
        document.head.appendChild(script);
        return new Promise((resolve) => { script.onload = resolve; });
    }

    async loadPenMappings() {
        try {
            const mappingPath = 'Attachments/pen_mapping.json';
            const mappingFile = this.app.vault.getAbstractFileByPath(mappingPath);
            if (mappingFile instanceof TFile) {
                const content = await this.app.vault.read(mappingFile);
                this.penMappings = JSON.parse(content);
                console.log('Loaded pen mappings from Attachments/pen_mapping.json');
            } else {
                this.penMappings = this.getKnownPenMappings();
                console.log('Using default pen mappings');
            }
        } catch (error) {
            console.error('Failed to load pen mappings:', error);
            this.penMappings = this.getKnownPenMappings();
        }
    }

    getKnownPenMappings(): PenMappings {
        const mappings: PenMappings = {};
        const penTypes = ['calligraphy', 'fountain', 'ballpoint', 'fineliner', 'pencil', 'highlighter', 'thinkers'];
        const colors = ['black', 'gray', 'blue', 'red', 'green'];
        const thicknesses = ['Ultra Fine', 'Fine', 'Medium', 'Medium Bold', 'Bold'];
        let penId = 0;
        for (const type of penTypes) {
            const colorsForType = type === 'highlighter' ? ['yellow', 'green', 'blue', 'red', 'gray'] : colors;
            for (const color of colorsForType) {
                for (const thickness of thicknesses) {
                    mappings[penId] = { type, color, thickness, opacity: type === 'highlighter' ? 0.3 : (type === 'pencil' ? 0.8 : 1) };
                    penId++;
                }
            }
        }
        return mappings;
    }

    handleDragOver(evt: DragEvent) {
        if (evt.dataTransfer && this.hasNoteFile(evt.dataTransfer)) {
            evt.preventDefault();
            evt.dataTransfer.dropEffect = 'copy';
        }
    }

    async handleDrop(evt: DragEvent) {
        if (!evt.dataTransfer || !this.hasNoteFile(evt.dataTransfer)) return;
        evt.preventDefault();
        const files = Array.from(evt.dataTransfer.files);
        const noteFiles = files.filter(f => f.name.endsWith('.note') || f.name.endsWith('.zip'));
        if (noteFiles.length > 0) {
            for (const file of noteFiles) await this.processNoteFile(file);
        }
    }

    hasNoteFile(dataTransfer: DataTransfer | null): boolean {
        if (!dataTransfer) return false;
        for (const item of Array.from(dataTransfer.items)) {
            if (item.kind === 'file') {
                const file = item.getAsFile();
                if (file && (file.name.endsWith('.note') || file.name.endsWith('.zip'))) return true;
            }
        }
        return false;
    }

    async hashImageData(blob: Blob): Promise<string> {
        try {
            const buffer = await blob.arrayBuffer();
            const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            return hashHex.substring(0, 32);
        } catch (error) {
            console.error('Error hashing image:', error);
            return `fallback-${blob.size}`.padEnd(32, '0').substring(0, 32);
        }
    }

    async analyzeChanges(bookResult: BookResult, existingManifest: ImportManifest | null): Promise<{ changes: PageChange[]; summary: ImportSummary; }> {
        const changes: PageChange[] = [];
        const summary: ImportSummary = { totalPages: bookResult.pages.length, newPages: [], modifiedPages: [], unchangedPages: [], deletedPages: [], errors: [] };
        const bookFolder = `${this.settings.notesFolder}/${bookResult.bookName}`;

        if (!existingManifest) {
            for (const page of bookResult.pages) {
                changes.push({ pageNum: page.pageNum, type: 'new', newHash: page.image.hash });
                summary.newPages.push(page.pageNum);
            }
            console.log('No existing manifest - all pages are new');
            return { changes, summary };
        }

        const existingMap = new Map<number, { manifestInfo: any, fileHash?: string }>();
        Object.entries(existingManifest.importedPages).forEach(([pageNum, info]) => {
            existingMap.set(parseInt(pageNum), { manifestInfo: info });
        });

        for (const [pageNum, data] of existingMap.entries()) {
            const pageFileName = `Page ${String(pageNum).padStart(3, '0')}.md`;
            const pagePath = `${bookFolder}/${pageFileName}`;
            const pageFile = this.app.vault.getAbstractFileByPath(pagePath);
            if (pageFile instanceof TFile) {
                try {
                    const content = await this.app.vault.read(pageFile);
                    const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
                    const match = content.match(frontmatterRegex);
                    if (match) {
                        const frontmatter = match[1];
                        const hashMatch = frontmatter.match(/original_image_hash:\s*"?([a-f0-9]+)"?/);
                        if (hashMatch) {
                            data.fileHash = hashMatch[1];
                            console.log(`Page ${pageNum}: Found hash in file: ${hashMatch[1].substring(0, 8)}...`);
                        }
                    }
                } catch (error) {
                    console.error(`Failed to read hash from page ${pageNum}:`, error);
                }
            }
        }

        for (const page of bookResult.pages) {
            const existing = existingMap.get(page.pageNum);
            if (!existing) {
                changes.push({ pageNum: page.pageNum, type: 'new', newHash: page.image.hash });
                summary.newPages.push(page.pageNum);
            } else {
                const existingHash = existing.fileHash || existing.manifestInfo.imageHash;
                const isRecoveredHash = existingHash.startsWith('recovered-');
                const isResetHash = existingHash.startsWith('RESET-');
                const hashesMatch = existingHash === page.image.hash;
                if (isRecoveredHash || isResetHash) {
                    console.log(`Page ${page.pageNum}: Special hash (${isRecoveredHash ? 'recovered' : 'reset'}), treating as modified`);
                    changes.push({ pageNum: page.pageNum, type: 'modified', oldHash: existingHash, newHash: page.image.hash, hasAudioChange: !!page.audio !== !!existing.manifestInfo.hasAudio });
                    summary.modifiedPages.push(page.pageNum);
                } else if (!hashesMatch) {
                    console.log(`Page ${page.pageNum} modified: ${existingHash.substring(0, 8)}... ‚Üí ${page.image.hash.substring(0, 8)}...`);
                    console.log(`  Source: ${existing.fileHash ? 'file frontmatter' : 'manifest'}`);
                    changes.push({ pageNum: page.pageNum, type: 'modified', oldHash: existingHash, newHash: page.image.hash, hasAudioChange: !!page.audio !== !!existing.manifestInfo.hasAudio });
                    summary.modifiedPages.push(page.pageNum);
                } else {
                    changes.push({ pageNum: page.pageNum, type: 'unchanged', oldHash: existingHash, newHash: page.image.hash });
                    summary.unchangedPages.push(page.pageNum);
                }
                existingMap.delete(page.pageNum);
            }
        }

        existingMap.forEach((data, pageNum) => {
            const hash = data.fileHash || data.manifestInfo.imageHash;
            changes.push({ pageNum, type: 'deleted', oldHash: hash });
            summary.deletedPages.push(pageNum);
        });

        console.log('Change Analysis Summary:', { total: bookResult.pages.length, new: summary.newPages.length, modified: summary.modifiedPages.length, unchanged: summary.unchangedPages.length, deleted: summary.deletedPages.length });
        return { changes, summary };
    }

    async createManifestBackup(manifestPath: string): Promise<string | null> {
        if (!this.settings.createBackups) return null;
        try {
            const manifestFile = this.app.vault.getAbstractFileByPath(manifestPath);
            if (manifestFile instanceof TFile) {
                const content = await this.app.vault.read(manifestFile);
                const backupPath = manifestPath.replace('.json', `-backup-${Date.now()}.json`);
                await this.app.vault.create(backupPath, content);
                return backupPath;
            }
        } catch (error) {
            console.error('Failed to create manifest backup:', error);
        }
        return null;
    }

    addHistoryEntry(manifest: ImportManifest, action: string, pages: number[], summary: string) {
        if (!this.settings.keepHistory) return;
        if (!manifest.history) manifest.history = [];
        manifest.history.unshift({ date: new Date().toISOString(), action: action as any, pages, summary });
        if (manifest.history.length > this.settings.maxHistoryEntries) {
            manifest.history = manifest.history.slice(0, this.settings.maxHistoryEntries);
        }
    }

    async recoverManifestFromExistingFiles(bookFolder: string, bookName: string): Promise<ImportManifest | null> {
        console.log(`Attempting to recover manifest for ${bookName}`);
        const folder = this.app.vault.getAbstractFileByPath(bookFolder);
        if (!(folder instanceof TFolder)) return null;
        const manifest: ImportManifest = { bookName: bookName, totalPages: 0, importedPages: {}, lastImport: new Date().toISOString(), sourceFile: bookName, version: '1.1', history: [] };
        const pageRegex = /^Page (\d{3})\.md$/;
        let maxPage = 0;
        for (const child of folder.children) {
            if (child instanceof TFile) {
                const match = child.name.match(pageRegex);
                if (match) {
                    const pageNum = parseInt(match[1]);
                    maxPage = Math.max(maxPage, pageNum);
                    const content = await this.app.vault.read(child);
                    const hasGemini = content.includes('### Gemini Transcription');
                    const hasAudio = content.includes('üéôÔ∏è Audio Recording');
                    let imageHash = 'recovered-unknown-' + pageNum;
                    const imageFileName = `${bookName}_page_${String(pageNum).padStart(3, '0')}.png`;
                    const imagePath = `${bookFolder}/${this.settings.imagesFolder}/${imageFileName}`;
                    const imageFile = this.app.vault.getAbstractFileByPath(imagePath);
                    if (imageFile instanceof TFile) {
                        imageHash = `recovered-${imageFile.stat.size}-${imageFile.stat.mtime}`;
                        console.log(`Using recovered placeholder hash for page ${pageNum}: ${imageHash}`);
                    }
                    manifest.importedPages[pageNum] = { fileName: child.name, importDate: new Date(child.stat.mtime).toISOString(), imageHash: imageHash, geminiProcessed: hasGemini, hasAudio: hasAudio, lastModified: new Date(child.stat.mtime).toISOString(), size: child.stat.size };
                }
            }
        }
        manifest.totalPages = maxPage;
        if (Object.keys(manifest.importedPages).length > 0) {
            console.log(`Recovered manifest with ${Object.keys(manifest.importedPages).length} pages`);
            this.addHistoryEntry(manifest, 'import', Object.keys(manifest.importedPages).map(Number), 'Manifest recovered from existing files');
            const manifestPath = `${bookFolder}/.import-manifest.json`;
            try {
                await this.saveManifest(manifestPath, manifest);
            } catch (error) {
                console.error('Failed to save recovered manifest:', error);
            }
            return manifest;
        }
        return null;
    }
    
    async loadManifest(manifestPath: string): Promise<ImportManifest | null> {
        console.log(`Attempting to load manifest from: ${manifestPath}`);
        const manifestFile = this.app.vault.getAbstractFileByPath(manifestPath);
        if (manifestFile instanceof TFile) {
            const content = await this.app.vault.read(manifestFile);
            const manifest = JSON.parse(content);
            console.log(`Loaded manifest with ${Object.keys(manifest.importedPages).length} pages`);
            return manifest;
        }
        console.log('No manifest file found');
        return null;
    }

    async saveManifest(manifestPath: string, manifest: ImportManifest) {
        console.log(`Saving manifest to: ${manifestPath}`);
        console.log(`Manifest contains ${Object.keys(manifest.importedPages).length} pages`);
        const manifestFile = this.app.vault.getAbstractFileByPath(manifestPath);
        const content = JSON.stringify(manifest, null, 2);
        try {
            if (manifestFile instanceof TFile) {
                await this.app.vault.modify(manifestFile, content);
                console.log('Manifest updated successfully');
            } else {
                await this.app.vault.create(manifestPath, content);
                console.log('Manifest created successfully');
            }
        } catch (error) {
            console.error('Failed to save manifest:', error);
            try {
                const folder = manifestPath.substring(0, manifestPath.lastIndexOf('/'));
                await this.ensureFolder(folder);
                await this.app.vault.adapter.write(manifestPath, content);
                console.log('Manifest saved using adapter');
            } catch (fallbackError) {
                console.error('Failed to save manifest using fallback:', fallbackError);
            }
        }
    }

    async processNoteFile(file: File) {
        if (this.importInProgress) {
            new Notice('Import already in progress');
            return;
        }
        this.importInProgress = true;
        try {
            const JSZip = window.JSZip;
            if (!JSZip) {
                new Notice('JSZip library not loaded. Please restart Obsidian.');
                return;
            }
            const zip = await JSZip.loadAsync(file);
            const files = Object.keys(zip.files);
            const isNewFormat = files.some(f => f.includes('NoteFileInfo.json'));
            const bookResult = await this.convertNoteToBook(zip, files, file.name, isNewFormat);
            const bookFolder = `${this.settings.notesFolder}/${bookResult.bookName}`;
            const manifestPath = `${bookFolder}/.import-manifest.json`;
            let existingManifest = await this.loadManifest(manifestPath);
            if (!existingManifest) {
                const folderExists = this.app.vault.getAbstractFileByPath(bookFolder);
                if (folderExists instanceof TFolder) {
                    console.log('Book folder exists but no manifest, attempting recovery...');
                    existingManifest = await this.recoverManifestFromExistingFiles(bookFolder, bookResult.bookName);
                }
            }
            let backupPath: string | null = null;
            if (existingManifest && this.settings.createBackups) {
                backupPath = await this.createManifestBackup(manifestPath);
            }
            let analysis = null;
            if (this.settings.autoDetectChanges && existingManifest) {
                analysis = await this.analyzeChanges(bookResult, existingManifest);
            }
            const pagesToImport = await this.showEnhancedImportDialog(bookResult, existingManifest, analysis);
            if (pagesToImport.length === 0) {
                new Notice('Import cancelled or no pages selected');
                return;
            }
            const summary = await this.importSelectedPagesWithProgress(bookResult, pagesToImport, existingManifest);
            new ImportSummaryModal(this.app, summary, backupPath).open();
        } catch (error: any) {
            console.error('Error processing note file:', error);
            new Notice(`Failed to import: ${file.name}\n${error.message}`);
        } finally {
            this.importInProgress = false;
        }
    }

    async convertNoteToBook(zip: any, files: string[], fileName: string, isNewFormat: boolean): Promise<BookResult> {
        let bookName = fileName.replace('.note', '').replace('.zip', '');
        let metadata: any = {};
        const pages: PageData[] = [];
        console.log(`Converting note to book: ${fileName}, format: ${isNewFormat ? 'new' : 'old'}`);
        console.log(`Total files in archive: ${files.length}`);
        const allAudioFiles = files.filter(f => f.includes('audio') || f.endsWith('.m4a') || f.endsWith('.mp3'));
        console.log(`Found ${allAudioFiles.length} audio files:`, allAudioFiles);

        if (isNewFormat) {
            const noteFileInfo = files.find(f => f.includes('NoteFileInfo.json'));
            if (noteFileInfo) {
                metadata = JSON.parse(await zip.file(noteFileInfo).async('string'));
                bookName = this.settings.filePrefix + (metadata.fileName || bookName);
                console.log(`Book name from metadata: ${bookName}`);
            }
            const pageResourceFile = files.find(f => f.includes('PageResource.json'));
            if (pageResourceFile) {
                const pageResource = JSON.parse(await zip.file(pageResourceFile).async('string'));
                const mainBmpFiles = pageResource.filter((r: any) => r.fileName?.includes('mainBmp'));
                console.log(`Processing ${mainBmpFiles.length} pages`);
                for (let i = 0; i < mainBmpFiles.length; i++) {
                    const bmpResource = mainBmpFiles[i];
                    const imageFile = files.find(f => f === bmpResource.fileName);
                    if (imageFile) {
                        const blob = await zip.file(imageFile).async('blob');
                        const hash = await this.hashImageData(blob);
                        const pageData: PageData = { pageNum: i + 1, image: { blob, hash } };
                        if (this.settings.outputFormat === 'svg' || this.settings.outputFormat === 'both' || this.settings.enableSvgViewer) {
                            const pathFiles = pageResource.filter((r: any) => r.resourceType === 7);
                            const pathResource = pathFiles[i];
                            if (pathResource) {
                                const pathFile = files.find(f => f.includes(pathResource.fileName));
                                if (pathFile) pageData.stroke = JSON.parse(await zip.file(pathFile).async('string'));
                            }
                        }
                        const pageNum = i + 1;
                        const audioPatterns = [
                            `audio/page_${pageNum}`, `audio/Page_${pageNum}`, `page_${pageNum}.m4a`,
                            `Page${String(pageNum).padStart(3, '0')}`, `audio/${pageNum}`,
                            (f: string) => {
                                const audioMatch = f.match(/audio[\/\\].*?(\d+)/i);
                                return audioMatch && parseInt(audioMatch[1]) === pageNum;
                            }
                        ];
                        let audioFile = null;
                        for (const pattern of audioPatterns) {
                            if (typeof pattern === 'string') {
                                audioFile = files.find(f => f.includes(pattern));
                            } else if (typeof pattern === 'function') {
                                audioFile = files.find(f => pattern(f));
                            }
                            if (audioFile) {
                                console.log(`Found audio for page ${pageNum} using pattern`);
                                break;
                            }
                        }
                        if (!audioFile && allAudioFiles.length > 0) {
                            const sortedAudioFiles = allAudioFiles.sort();
                            if (sortedAudioFiles[i]) {
                                audioFile = sortedAudioFiles[i];
                                console.log(`Using audio file by index for page ${pageNum}: ${audioFile}`);
                            }
                        }
                        if (audioFile) {
                            const audioBlob = await zip.file(audioFile).async('blob');
                            const audioFileName = audioFile.split('/').pop() || audioFile.split('\\').pop();
                            pageData.audio = { blob: audioBlob, originalName: audioFileName || '', name: `${bookName}_page_${String(pageNum).padStart(3, '0')}_audio.m4a` };
                            console.log(`Added audio for page ${pageNum}: ${audioFile}`);
                        } else {
                            console.log(`No audio found for page ${pageNum}`);
                        }
                        pages.push(pageData);
                    }
                }
            }
        } else {
            const notesBeanFile = files.find(f => f.includes('NotesBean.json'));
            if (notesBeanFile) {
                metadata = JSON.parse(await zip.file(notesBeanFile).async('string'));
                bookName = this.settings.filePrefix + (metadata.nickname || metadata.noteName || bookName);
                console.log(`Book name from old format metadata: ${bookName}`);
            }
            const noteListFile = files.find(f => f.includes('NoteList.json'));
            if (noteListFile) {
                const noteList = JSON.parse(await zip.file(noteListFile).async('string'));
                console.log(`Processing ${noteList.length} pages from old format`);
                for (let i = 0; i < noteList.length; i++) {
                    const page = noteList[i];
                    const imageFile = files.find(f => f === `${page.pageId}.png`);
                    if (imageFile) {
                        const blob = await zip.file(imageFile).async('blob');
                        const hash = await this.hashImageData(blob);
                        const pageData: PageData = { pageNum: i + 1, image: { blob, hash } };
                        const pageNum = i + 1;
                        const audioFile = files.find(f => (f.includes('audio') || f.endsWith('.m4a')) && (f.includes(`${pageNum}`) || f.includes(`page${pageNum}`) || f.includes(`Page${pageNum}`)));
                        if (audioFile) {
                            const audioBlob = await zip.file(audioFile).async('blob');
                            const audioFileName = audioFile.split('/').pop() || audioFile.split('\\').pop();
                            pageData.audio = { blob: audioBlob, originalName: audioFileName || '', name: `${bookName}_page_${String(pageNum).padStart(3, '0')}_audio.m4a` };
                            console.log(`Added audio for page ${pageNum} (old format): ${audioFile}`);
                        }
                        pages.push(pageData);
                    }
                }
            }
        }

        let thumbnail = null;
        if (this.settings.includeThumbnails) {
            const thumbnailFile = files.find(f => f.includes('Thumbnail') || f.includes('thumbnai'));
            if (thumbnailFile) {
                thumbnail = await zip.file(thumbnailFile).async('blob');
                console.log('Found thumbnail');
            }
        }
        console.log(`Conversion complete: ${pages.length} pages, ${pages.filter(p => p.audio).length} with audio`);
        return { bookName, metadata, pages, thumbnail };
    }

    async showEnhancedImportDialog(bookResult: BookResult, existingManifest: ImportManifest | null, analysis: { changes: PageChange[], summary: ImportSummary } | null): Promise<number[]> {
        return new Promise((resolve) => {
            const modal = new EnhancedImportModal(this.app, bookResult, existingManifest, analysis, this.settings);
            modal.onChoose = (pages: number[]) => resolve(pages);
            modal.open();
        });
    }

    async importSelectedPagesWithProgress(bookResult: BookResult, pagesToImport: number[], existingManifest: ImportManifest | null): Promise<ImportSummary> {
        const bookFolder = `${this.settings.notesFolder}/${bookResult.bookName}`;
        await this.ensureFolder(bookFolder);
        const imagesFolder = `${bookFolder}/${this.settings.imagesFolder}`;
        await this.ensureFolder(imagesFolder);
        const audioFolder = `${bookFolder}/${this.settings.audioFolder}`;
        const strokesFolder = `${bookFolder}/${this.settings.strokesFolder}`;
        await this.ensureFolder(strokesFolder);
        const manifestFilePath = `${bookFolder}/.import-manifest.json`;
        const manifest: ImportManifest = existingManifest || { bookName: bookResult.bookName, totalPages: 0, importedPages: {}, lastImport: new Date().toISOString(), sourceFile: bookResult.bookName, version: '1.1', history: [] };
        manifest.totalPages = Math.max(manifest.totalPages, bookResult.pages.length);
        const summary: ImportSummary = { totalPages: pagesToImport.length, newPages: [], modifiedPages: [], unchangedPages: [], deletedPages: [], errors: [] };
        const progressModal = new ProgressModal(this.app, pagesToImport.length);
        if (this.settings.enableProgressBar) progressModal.open();
        const imageFilesToProcess: { file: TFile, pageNum: number }[] = [];
        const batchSize = this.settings.batchSize;

        for (let batchStart = 0; batchStart < pagesToImport.length; batchStart += batchSize) {
            const batch = pagesToImport.slice(batchStart, Math.min(batchStart + batchSize, pagesToImport.length));
            const batchPromises = batch.map(async (pageNum) => {
                const page = bookResult.pages.find(p => p.pageNum === pageNum);
                if (!page) return;
                try {
                    const i = pagesToImport.indexOf(pageNum);
                    progressModal.updateProgress(i + 1, `Processing page ${pageNum}...`);
                    const isNew = !existingManifest?.importedPages[pageNum];
                    const isModified = existingManifest?.importedPages[pageNum]?.imageHash !== page.image.hash;
                    if (isNew) summary.newPages.push(pageNum);
                    else if (isModified) summary.modifiedPages.push(pageNum);
                    else summary.unchangedPages.push(pageNum);

                    // Save stroke data
                    if (page.stroke) {
                        const strokeFileName = `${bookResult.bookName}_page_${String(pageNum).padStart(3, '0')}_strokes.json`;
                        const strokePath = `${strokesFolder}/${strokeFileName}`;
                        const normalizedStrokePath = normalizePath(strokePath);
                        const existingStroke = this.app.vault.getAbstractFileByPath(normalizedStrokePath);
                        const strokeContent = JSON.stringify(page.stroke, null, 2);
                        if (existingStroke instanceof TFile) {
                            if (isNew || isModified) await this.app.vault.modify(existingStroke, strokeContent);
                        } else {
                            await this.app.vault.create(normalizedStrokePath, strokeContent);
                        }
                        
                        // AUTO-CREATE PDF from strokes
                        if (this.settings.autoCreatePdfOnImport) {
                            try {
                                await this.ensureFolder(this.settings.pdfFolder);
                                //const pdfFileName = `${bookResult.bookName}_page_${String(pageNum).padStart(3, '0')}.png`;
                                const pdfFileName = `${bookResult.bookName}_page_${String(pageNum).padStart(3, '0')}.pdf`;
                                const pdfPath = `${this.settings.pdfFolder}/${pdfFileName}`;
                                await this.generatePdfFromStrokes(page.stroke, pdfPath, isNew || isModified);
                            } catch (pdfError) {
                                console.error(`Failed to generate PDF for page ${pageNum}:`, pdfError);
                            }
                        }
                    }

                    // Build page content
                    const pageFileName = `Page ${String(pageNum).padStart(3, '0')}.md`;
                    const pagePath = `${bookFolder}/${pageFileName}`;
                    let pageContent = '';

                    // 1. Metadata (frontmatter)
                    if (this.settings.includeMetadata) {
                        pageContent += '---\n';
                        pageContent += `book: "${bookResult.bookName}"\n`;
                        pageContent += `page: ${pageNum}\n`;
                        pageContent += `total_pages: ${manifest.totalPages}\n`;
                        pageContent += `original_image_hash: "${page.image.hash}"\n`;
                        if (this.settings.includeTimestamps) {
                            const createTime = bookResult.metadata.createTime || bookResult.metadata.creationTime;
                            const updateTime = bookResult.metadata.upTime || bookResult.metadata.lastModifiedTime;
                            if (createTime) pageContent += `book_created: ${this.formatDate(createTime)}\n`;
                            if (updateTime) pageContent += `book_updated: ${this.formatDate(updateTime)}\n`;
                        }
                        pageContent += `import_date: ${new Date().toISOString()}\n`;
                        if (isModified) pageContent += `last_modified: ${new Date().toISOString()}\n`;
                        if (page.audio) pageContent += 'has_audio: true\n';
                        if (page.stroke) pageContent += 'has_strokes: true\n';
                        const imageName = `${bookResult.bookName}_page_${String(pageNum).padStart(3, '0')}.png`;
                        pageContent += `image: "${imageName}"\n`;
                        const bookTag = bookResult.bookName.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-_]/g, '').replace(/-+/g, '-').replace(/^-|-$/g, '');
                        pageContent += 'tags: [viwoods-import, handwritten, ' + bookTag + ']\n';
                        pageContent += '---\n\n';
                    }

                    // 2. Audio (if exists)
                    if (page.audio) {
                        await this.ensureFolder(audioFolder);
                        const audioPath = `${audioFolder}/${page.audio.name}`;
                        const normalizedAudioPath = normalizePath(audioPath);
                        const existingAudio = this.app.vault.getAbstractFileByPath(normalizedAudioPath);
                        if (existingAudio instanceof TFile) {
                            if (isNew || isModified) {
                                await this.app.vault.delete(existingAudio);
                                await this.app.vault.createBinary(normalizedAudioPath, await page.audio.blob.arrayBuffer());
                            }
                        } else {
                            await this.app.vault.createBinary(normalizedAudioPath, await page.audio.blob.arrayBuffer());
                        }
                        pageContent += `## üéôÔ∏è Audio Recording\n\n`;
                        pageContent += `![[${page.audio.name}]]\n\n`;
                        pageContent += '---\n\n';
                    }

                    // 3. Original Image
                    let imageFile: TFile | undefined;
                    if (this.settings.outputFormat === 'png' || this.settings.outputFormat === 'both') {
                        const imageName = `${bookResult.bookName}_page_${String(pageNum).padStart(3, '0')}.png`;
                        const imagePath = `${imagesFolder}/${imageName}`;
                        const normalizedImagePath = normalizePath(imagePath);
                        const existingImage = this.app.vault.getAbstractFileByPath(normalizedImagePath);
                        try {
                            const needsImageUpdate = isNew || isModified;
                            const backgroundChanged = existingManifest?.importedPages[pageNum]?.backgroundColor !== this.settings.backgroundColor;
                            if (existingImage instanceof TFile) {
                                if (needsImageUpdate || backgroundChanged) {
                                    const processedImage = await this.processImageWithBackground(page.image.blob);
                                    await this.app.vault.delete(existingImage);
                                    imageFile = await this.app.vault.createBinary(normalizedImagePath, processedImage);
                                    console.log(`Updated image for page ${pageNum}`);
                                } else {
                                    imageFile = existingImage;
                                }
                            } else {
                                const processedImage = await this.processImageWithBackground(page.image.blob);
                                imageFile = await this.app.vault.createBinary(normalizedImagePath, processedImage);
                            }
                            
                            pageContent += `## Original Image\n\n`;
                            pageContent += `![[${imageName}]]\n\n`;
                        } catch (imageError) {
                            console.error(`Failed to process image for page ${pageNum}:`, imageError);
                            pageContent += `*[Image failed to import]*\n\n`;
                        }
                    }

                    // 4. SVG Viewer (if enabled and has strokes)
                    if (this.settings.enableSvgViewer && page.stroke) {
                        pageContent += `## Vector Viewer\n\n`;
                        const strokeFileName = `${bookResult.bookName}_page_${String(pageNum).padStart(3, '0')}_strokes.json`;
                        pageContent += `\`\`\`viwoods-svg\n${strokeFileName}\n\`\`\`\n\n`;
                        
                        // Add link to rendered PDF
                        //const pdfName = `${bookResult.bookName}_page_${String(pageNum).padStart(3, '0')}.png`;
                        const pdfName = `${bookResult.bookName}_page_${String(pageNum).padStart(3, '0')}.pdf`;
                        pageContent += `**Rendered Export**: [[${this.settings.pdfFolder}/${pdfName}]]\n\n`;
                    }

                    // 5. SVG format (if selected)
                    if ((this.settings.outputFormat === 'svg' || this.settings.outputFormat === 'both') && page.stroke) {
                        const svgContent = this.strokesToSVG(page.stroke);
                        const svgName = `${bookResult.bookName}_page_${String(pageNum).padStart(3, '0')}.svg`;
                        const svgPath = `${imagesFolder}/${svgName}`;
                        const normalizedSvgPath = normalizePath(svgPath);
                        const existingSvg = this.app.vault.getAbstractFileByPath(normalizedSvgPath);
                        if (existingSvg instanceof TFile) {
                            if (isNew || isModified) await this.app.vault.modify(existingSvg, svgContent);
                        } else {
                            await this.app.vault.create(normalizedSvgPath, svgContent);
                        }
                    }

                    // Save the markdown file
                    const existingFile = this.app.vault.getAbstractFileByPath(pagePath);
                    if (existingFile instanceof TFile) {
                        await this.app.vault.modify(existingFile, pageContent);
                    } else {
                        await this.app.vault.create(pagePath, pageContent);
                    }

                    // Update manifest
                    manifest.importedPages[pageNum] = { 
                        fileName: pageFileName, 
                        importDate: new Date().toISOString(), 
                        imageHash: page.image.hash, 
                        geminiProcessed: manifest.importedPages[pageNum]?.geminiProcessed || false, 
                        hasAudio: !!page.audio, 
                        lastModified: new Date().toISOString(), 
                        size: page.image.blob.size, 
                        backgroundColor: this.settings.backgroundColor 
                    };
                    
                    // Mark for Gemini processing if needed (content will be appended after SVG viewer)
                    if (this.settings.processWithGemini && (isNew || isModified) && imageFile) {
                        imageFilesToProcess.push({ file: imageFile, pageNum });
                    }
                } catch (error: any) {
                    console.error(`Failed to import page ${pageNum}:`, error);
                    summary.errors.push({ page: pageNum, error: error.message });
                }
            });
            await Promise.all(batchPromises);
            await new Promise(resolve => setTimeout(resolve, 100));
        }

        progressModal.close();
        const historyMessage = `Imported ${summary.newPages.length} new, ${summary.modifiedPages.length} modified pages`;
        this.addHistoryEntry(manifest, 'import', pagesToImport, historyMessage);
        if (this.settings.createIndex) await this.createBookIndex(bookFolder, bookResult.bookName, manifest);
        await this.saveManifest(manifestFilePath, manifest);
        
        // Process with Gemini AFTER all pages are created (Gemini content will be appended)
        if (this.settings.processWithGemini && imageFilesToProcess.length > 0) {
            await this.processWithGemini(bookFolder, imageFilesToProcess, manifest);
        }
        return summary;
    }
    
    async generatePdfFromStrokes(strokeData: any, outputPath: string, forceUpdate: boolean): Promise<void> {
        const normalizedPath = normalizePath(outputPath);
        const existingFile = this.app.vault.getAbstractFileByPath(normalizedPath);
        
        // Skip if file exists and we're not forcing update
        if (existingFile instanceof TFile && !forceUpdate) {
            return;
        }
        
        // Check if jsPDF is loaded
        if (!window.jspdf) {
            console.error('jsPDF library not loaded');
            return;
        }
        
        const { jsPDF } = window.jspdf;
        
        // Create PDF document
        const pdf = new jsPDF({
            orientation: 'portrait',
            unit: 'pt',
            format: 'a4' // 595 x 842 points
        });
        
        // Normalize and scale stroke data to fit A4 canvas
        let normalizedData = [...strokeData];
        if (normalizedData.length > 0) {
            const baseWidth = 595;
            const baseHeight = 842;
            const padding = 50;

            const xCoords = normalizedData.map((p: number[]) => p[0]);
            const yCoords = normalizedData.map((p: number[]) => p[1]);
            const minX = Math.min(...xCoords);
            const maxX = Math.max(...xCoords);
            const minY = Math.min(...yCoords);
            const maxY = Math.max(...yCoords);

            const dataWidth = maxX - minX;
            const dataHeight = maxY - minY;
            const scaleX = (baseWidth - 2 * padding) / dataWidth;
            const scaleY = (baseHeight - 2 * padding) / dataHeight;
            const scale = Math.min(scaleX, scaleY);
            
            const scaledWidth = dataWidth * scale;
            const scaledHeight = dataHeight * scale;
            const offsetX = (baseWidth - scaledWidth) / 2 - minX * scale;
            const offsetY = (baseHeight - scaledHeight) / 2 - minY * scale;
            
            normalizedData = normalizedData.map((point: number[]) => [
                point[0] * scale + offsetX,
                point[1] * scale + offsetY,
                point[2]
            ]);
        }
        
        // Detect and render strokes using canvas first
        const canvas = document.createElement('canvas');
        canvas.width = 595 * 2;  // Higher resolution
        canvas.height = 842 * 2;
        const ctx = canvas.getContext('2d');
        
        if (!ctx) {
            throw new Error('Could not get canvas context');
        }
        
        // White background
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.scale(2, 2);
        
        // Detect strokes
        const sortedPoints = [...normalizedData].sort((a: number[], b: number[]) => a[2] - b[2]);
        const detectedStrokes: number[][][] = [];
        let currentStroke: number[][] = [];
        
        for (let i = 0; i < sortedPoints.length; i++) {
            if (i === 0) {
                currentStroke.push(sortedPoints[i]);
            } else {
                const prevPoint = sortedPoints[i - 1];
                const currPoint = sortedPoints[i];
                const timeDiff = currPoint[2] - prevPoint[2];
                const distance = Math.hypot(currPoint[0] - prevPoint[0], currPoint[1] - prevPoint[1]);
                
                if (timeDiff > 5 || distance > 100) {
                    if (currentStroke.length > 1) {
                        detectedStrokes.push(currentStroke);
                    }
                    currentStroke = [currPoint];
                } else {
                    currentStroke.push(currPoint);
                }
            }
        }
        if (currentStroke.length > 1) {
            detectedStrokes.push(currentStroke);
        }
        
        // Render each stroke on canvas
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 2.5;
        ctx.globalAlpha = 1;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        detectedStrokes.forEach(stroke => {
            if (stroke.length < 2) return;
            const smoothed = this.smoothPoints(stroke, this.settings.defaultSmoothness);
            
            ctx.beginPath();
            ctx.moveTo(smoothed[0][0], smoothed[0][1]);
            for (let i = 1; i < smoothed.length; i++) {
                ctx.lineTo(smoothed[i][0], smoothed[i][1]);
            }
            ctx.stroke();
        });
        
        // Convert canvas to image and add to PDF
        const imgData = canvas.toDataURL('image/jpeg', 0.95);
        pdf.addImage(imgData, 'JPEG', 0, 0, 595, 842);
        
        // Get PDF as ArrayBuffer
        const pdfBlob = pdf.output('blob');
        const arrayBuffer = await pdfBlob.arrayBuffer();
        
        // Save to vault
        try {
            if (existingFile instanceof TFile) {
                await this.app.vault.modifyBinary(existingFile, arrayBuffer);
            } else {
                await this.app.vault.createBinary(normalizedPath, arrayBuffer);
            }
        } catch (error) {
            console.error('Failed to save PDF:', error);
            throw error;
        }
    }
    
    async processImageWithBackground(blob: Blob): Promise<ArrayBuffer> {
        if (!this.settings.backgroundColor || this.settings.backgroundColor === 'transparent' || this.settings.backgroundColor === '#FFFFFF') {
            return await blob.arrayBuffer();
        }
        return new Promise((resolve, reject) => {
            const img = new Image();
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            if (!ctx) {
                reject(new Error('Could not get canvas context'));
                return;
            }
            img.onload = () => {
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.fillStyle = this.settings.backgroundColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0);
                canvas.toBlob(async (processedBlob) => {
                    if (processedBlob) {
                        resolve(await processedBlob.arrayBuffer());
                    } else {
                        reject(new Error('Failed to process image'));
                    }
                }, 'image/png', 1.0);
            };
            img.onerror = () => reject(new Error('Failed to load image'));
            img.src = URL.createObjectURL(blob);
        });
    }

    async createBookIndex(bookFolder: string, bookName: string, manifest: ImportManifest) {
        const indexPath = `${bookFolder}/Index.md`;
        const bookTag = bookName.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-_]/g, '').replace(/-+/g, '-').replace(/^-|-$/g, '');
        let indexContent = '---\ncssclasses: cards\n---\n\n';
        indexContent += '```dataview\nTABLE embed(link(image))\n';
        indexContent += `FROM #${bookTag}\nSORT page ASC\n\`\`\`\n`;
        const existingIndex = this.app.vault.getAbstractFileByPath(indexPath);
        if (existingIndex instanceof TFile) {
            await this.app.vault.modify(existingIndex, indexContent);
        } else {
            await this.app.vault.create(indexPath, indexContent);
        }
    }

    async processWithGemini(bookFolder: string, imageFiles: { file: TFile, pageNum: number }[], manifest: ImportManifest) {
        const app = this.app as any;
        if (!app.plugins?.enabledPlugins?.has('gemini-note-processor')) {
            new Notice('Gemini Note Processor plugin not found or disabled');
            return;
        }
        const geminiPlugin = app.plugins.plugins['gemini-note-processor'];
        if (!geminiPlugin) {
            new Notice('Could not access Gemini plugin');
            return;
        }
        new Notice(`Processing ${imageFiles.length} pages with Gemini AI...`);
        for (const { file, pageNum } of imageFiles) {
            try {
                const imageData = await this.app.vault.readBinary(file);
                const resultText = await geminiPlugin.callGeminiAPI(imageData);
                if (resultText) {
                    let processedText = resultText;
                    if (geminiPlugin.settings.enableTriggerWords) {
                        processedText = await geminiPlugin.processTriggersInText(resultText);
                    }
                    const pageDetectedTags: Set<string> = new Set();
                    const tagRegex = /### Detected Tags\s*\n(.*?)(?:\n###|$)/s;
                    const match = processedText.match(tagRegex);
                    if (match && match[1] && match[1].toLowerCase().trim() !== 'none identified.') {
                        const tags = match[1].split(',').map((tag: string) => tag.trim()).filter((tag: string) => tag);
                        tags.forEach((tag: string) => pageDetectedTags.add(tag));
                    }
                    const pageFileName = `Page ${String(pageNum).padStart(3, '0')}.md`;
                    const pagePath = `${bookFolder}/${pageFileName}`;
                    const pageFile = this.app.vault.getAbstractFileByPath(pagePath);
                    if (pageFile instanceof TFile) {
                        let content = await this.app.vault.read(pageFile);
                        
                        // Append Gemini content at the end (after SVG viewer section)
                        const geminiSection = `\n---\n\n## Gemini Transcription\n\n${processedText}\n`;
                        content += geminiSection;
                        
                        await this.app.vault.modify(pageFile, content);
                        await this.app.fileManager.processFrontMatter(pageFile, (frontmatter) => {
                            frontmatter.tags = frontmatter.tags || [];
                            if (!Array.isArray(frontmatter.tags)) frontmatter.tags = [frontmatter.tags];
                            const bookTag = manifest.bookName.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-_]/g, '').replace(/-+/g, '-').replace(/^-|-$/g, '');
                            const coreTags = ['viwoods-import', 'handwritten', bookTag];
                            coreTags.forEach(tag => { if (!frontmatter.tags.includes(tag)) frontmatter.tags.push(tag); });
                            pageDetectedTags.forEach((tag: string) => { if (!frontmatter.tags.includes(tag)) frontmatter.tags.push(tag); });
                            frontmatter.gemini_processed = true;
                            if (!frontmatter.original_image_hash && manifest.importedPages[pageNum]) {
                                frontmatter.original_image_hash = manifest.importedPages[pageNum].imageHash;
                            }
                        });
                        if (manifest.importedPages[pageNum]) manifest.importedPages[pageNum].geminiProcessed = true;
                    }
                }
                await new Promise(resolve => setTimeout(resolve, 500));
            } catch (error) {
                console.error(`Failed to process page ${pageNum} with Gemini:`, error);
            }
        }
        const manifestPath = `${bookFolder}/.import-manifest.json`;
        await this.saveManifest(manifestPath, manifest);
        if (this.settings.createIndex) await this.createBookIndex(bookFolder, manifest.bookName, manifest);
        new Notice(`Gemini processing complete!`);
    }

    strokesToSVG(strokes: number[][], width = 1440, height = 1920): string {
        if (!strokes || strokes.length === 0) return '';
        const paths: number[][][] = [];
        let currentPath: number[][] = [];
        for (let i = 0; i < strokes.length; i++) {
            const [x, y, timestamp] = strokes[i];
            if (i > 0 && Math.abs(timestamp - strokes[i-1][2]) > 100) {
                if (currentPath.length > 0) paths.push(currentPath);
                currentPath = [[x, y]];
            } else {
                currentPath.push([x, y]);
            }
        }
        if (currentPath.length > 0) paths.push(currentPath);
        const svgPaths = paths.map(path => {
            if (path.length < 2) return '';
            let d = `M ${path[0][0]} ${path[0][1]}`;
            for (let i = 1; i < path.length; i++) d += ` L ${path[i][0]} ${path[i][1]}`;
            return `<path d="${d}" stroke="black" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>`;
        }).join('\n');
        return `<svg viewBox="0 0 ${width} ${height}" xmlns="http://www.w3.org/2000/svg">\n${svgPaths}\n</svg>`;
    }

    formatDate(timestamp: number): string {
        const date = new Date(timestamp);
        switch (this.settings.dateFormat) {
            case 'iso': return date.toISOString().split('T')[0];
            case 'us': return date.toLocaleDateString('en-US');
            case 'eu': return date.toLocaleDateString('en-GB');
            default: return date.toISOString();
        }
    }

    async ensureFolder(path: string) {
        const folders = path.split('/');
        let currentPath = '';
        for (const folder of folders) {
            currentPath = currentPath ? `${currentPath}/${folder}` : folder;
            const normalizedPath = normalizePath(currentPath);
            const folderExists = this.app.vault.getAbstractFileByPath(normalizedPath);
            if (!folderExists) {
                try {
                    await this.app.vault.createFolder(normalizedPath);
                } catch (error) {
                    const checkAgain = this.app.vault.getAbstractFileByPath(normalizedPath);
                    if (!checkAgain) {
                        console.error(`Failed to create folder ${normalizedPath}:`, error);
                        throw error;
                    }
                }
            }
        }
    }
    
    async renderSvgViewer(source: string, el: HTMLElement, ctx: MarkdownPostProcessorContext) {
        const lines = source.trim().split('\n');
        const strokeFileName = lines[0].trim();
        const currentFile = this.app.workspace.getActiveFile();
        if (!currentFile) return;
        
        const currentFolder = currentFile.parent?.path || '';
        const strokePath = `${currentFolder}/${this.settings.strokesFolder}/${strokeFileName}`;
        const strokeFile = this.app.vault.getAbstractFileByPath(strokePath);
        
        if (!(strokeFile instanceof TFile)) {
            el.createEl('p', { text: `Stroke data not found: ${strokeFileName}` });
            return;
        }
        
        try {
            const strokeContent = await this.app.vault.read(strokeFile);
            let strokeData: number[][] = JSON.parse(strokeContent);
            
            console.log('=== SVG VIEWER DEBUG ===');
            console.log(`Raw data points: ${strokeData.length}`);
            
            if (strokeData.length > 0) {
                const baseWidth = 595;
                const baseHeight = 842;
                const padding = 50;

                const xCoords = strokeData.map(p => p[0]);
                const yCoords = strokeData.map(p => p[1]);
                const minX = Math.min(...xCoords);
                const maxX = Math.max(...xCoords);
                const minY = Math.min(...yCoords);
                const maxY = Math.max(...yCoords);

                const dataWidth = maxX - minX;
                const dataHeight = maxY - minY;
                const scaleX = (baseWidth - 2 * padding) / dataWidth;
                const scaleY = (baseHeight - 2 * padding) / dataHeight;
                const scale = Math.min(scaleX, scaleY);
                
                const scaledWidth = dataWidth * scale;
                const scaledHeight = dataHeight * scale;
                const offsetX = (baseWidth - scaledWidth) / 2 - minX * scale;
                const offsetY = (baseHeight - scaledHeight) / 2 - minY * scale;
                
                strokeData = strokeData.map(point => [
                    point[0] * scale + offsetX,
                    point[1] * scale + offsetY,
                    point[2]
                ]);
            }

            const sortedPoints = [...strokeData].sort((a, b) => a[2] - b[2]);
            const detectedStrokes: number[][][] = [];
            let currentStroke: number[][] = [];
            
            for (let i = 0; i < sortedPoints.length; i++) {
                if (i === 0) {
                    currentStroke.push(sortedPoints[i]);
                } else {
                    const prevPoint = sortedPoints[i - 1];
                    const currPoint = sortedPoints[i];
                    const timeDiff = currPoint[2] - prevPoint[2];
                    const distance = Math.hypot(currPoint[0] - prevPoint[0], currPoint[1] - prevPoint[1]);
                    
                    if (timeDiff > 5 || distance > 100) {
                        if (currentStroke.length > 1) {
                            detectedStrokes.push(currentStroke);
                        }
                        currentStroke = [currPoint];
                    } else {
                        currentStroke.push(currPoint);
                    }
                }
            }
            
            if (currentStroke.length > 1) {
                detectedStrokes.push(currentStroke);
            }

            console.log(`Detected ${detectedStrokes.length} strokes`);

            const container = el.createDiv({ cls: 'viwoods-svg-viewer' });
            container.style.cssText = 'background: var(--background-secondary); padding: 15px; border-radius: 8px; margin: 10px 0;';

            const header = container.createDiv();
            header.style.cssText = 'display: flex; justify-content: space-between; align-items: center; cursor: pointer; padding: 10px; background: var(--background-primary); border-radius: 5px; margin-bottom: 10px;';
            
            const headerTitle = header.createEl('h4', { text: 'Vector Viewer' });
            headerTitle.style.cssText = 'margin: 0; color: var(--text-normal);';
            
            const toggleIcon = header.createEl('span', { text: this.settings.showSvgViewer ? '‚ñº' : '‚ñ∂' });
            toggleIcon.style.cssText = 'color: var(--text-muted);';

            const contentWrapper = container.createDiv();
            contentWrapper.style.display = this.settings.showSvgViewer ? 'block' : 'none';

            header.addEventListener('click', () => {
                const isVisible = contentWrapper.style.display === 'block';
                contentWrapper.style.display = isVisible ? 'none' : 'block';
                toggleIcon.textContent = isVisible ? '‚ñ∂' : '‚ñº';
                this.settings.showSvgViewer = !isVisible;
                this.saveSettings();
            });

            const controls = contentWrapper.createDiv();
            controls.style.cssText = 'display: flex; flex-wrap: wrap; gap: 15px; padding: 10px; background: var(--background-primary); border-radius: 5px; margin-bottom: 15px; align-items: center;';
            
            const createControl = (label: string, type: string, min: string, max: string, value: string, step = '1') => {
                const group = controls.createDiv();
                group.style.cssText = 'display: flex; align-items: center; gap: 8px;';
                group.createEl('label', { text: label }).style.cssText = 'min-width: 70px; font-weight: 500;';
                const input = group.createEl('input', { type }) as HTMLInputElement;
                if (type === 'range') {
                    input.min = min;
                    input.max = max;
                    input.step = step;
                    input.value = value;
                    input.style.cssText = 'width: 120px;';
                    const valueSpan = group.createEl('span', { text: value });
                    valueSpan.style.cssText = 'min-width: 30px; font-weight: bold;';
                    input.addEventListener('input', () => {
                        valueSpan.textContent = input.value;
                    });
                } else if (type === 'color') {
                    input.value = value;
                    input.style.cssText = 'width: 50px; height: 30px;';
                }
                return input;
            };
            
            const smoothSlider = createControl('Smooth:', 'range', '0', '20', this.settings.defaultSmoothness.toString());
            const widthSlider = createControl('Width:', 'range', '0.5', '10', '2.5', '0.5');
            const opacitySlider = createControl('Opacity:', 'range', '0.1', '1', '1', '0.1');
            const colorPicker = createControl('Color:', 'color', '', '', '#000000');
            const speedSlider = createControl('Speed:', 'range', '1', '50', this.settings.defaultReplaySpeed.toString());
            
            const btnGroup = controls.createDiv();
            btnGroup.style.cssText = 'display: flex; gap: 8px; margin-left: auto;';
            
            const replayBtn = btnGroup.createEl('button', { text: 'Play' });
            replayBtn.style.cssText = 'padding: 6px 12px; cursor: pointer; background: var(--interactive-accent); color: var(--text-on-accent); border: none; border-radius: 4px;';
            
            const pdfBtn = btnGroup.createEl('button', { text: 'PDF' });
            pdfBtn.style.cssText = 'padding: 6px 12px; cursor: pointer; background: var(--interactive-accent); color: var(--text-on-accent); border: none; border-radius: 4px;';
            
            const svgContainer = contentWrapper.createDiv();
            svgContainer.style.cssText = 'display: flex; justify-content: center; background: white; border-radius: 5px; padding: 20px; position: relative;';
            
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg') as SVGSVGElement;
            svg.setAttribute('viewBox', '0 0 595 842');
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', 'auto');
            svg.style.background = 'white';
            svgContainer.appendChild(svg);
            
            let isReplaying = false;
            let replayStrokeIndex = 0;
            let replayPointIndex = 0;
            
            const renderStrokes = (upToStroke?: number, upToPoint?: number) => {
                const smoothness = parseInt(smoothSlider.value);
                const strokeWidth = parseFloat(widthSlider.value);
                const opacity = parseFloat(opacitySlider.value);
                const color = colorPicker.value;
                
                while (svg.firstChild) {
                    svg.removeChild(svg.firstChild);
                }
                
                const maxStroke = upToStroke !== undefined ? upToStroke : detectedStrokes.length;
                
                for (let s = 0; s < maxStroke; s++) {
                    const stroke = detectedStrokes[s];
                    if (stroke.length < 2) continue;
                    
                    const maxPoint = (s === upToStroke && upToPoint !== undefined) ? upToPoint : stroke.length;
                    const partialStroke = stroke.slice(0, maxPoint);
                    
                    if (partialStroke.length < 2) continue;
                    
                    const smoothed = this.smoothPoints(partialStroke, smoothness);
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    
                    let d = `M ${smoothed[0][0]} ${smoothed[0][1]}`;
                    for (let i = 1; i < smoothed.length - 1; i++) {
                        const xc = (smoothed[i][0] + smoothed[i + 1][0]) / 2;
                        const yc = (smoothed[i][1] + smoothed[i + 1][1]) / 2;
                        d += ` Q ${smoothed[i][0]} ${smoothed[i][1]}, ${xc} ${yc}`;
                    }
                    if (smoothed.length > 1) {
                        d += ` L ${smoothed[smoothed.length - 1][0]} ${smoothed[smoothed.length - 1][1]}`;
                    }
                    
                    path.setAttribute('d', d);
                    path.setAttribute('stroke', color);
                    path.setAttribute('stroke-width', strokeWidth.toString());
                    path.setAttribute('stroke-opacity', opacity.toString());
                    path.setAttribute('fill', 'none');
                    path.setAttribute('stroke-linecap', 'round');
                    path.setAttribute('stroke-linejoin', 'round');
                    
                    svg.appendChild(path);
                }
            };

            const startReplay = () => {
                if (isReplaying) {
                    isReplaying = false;
                    replayBtn.textContent = 'Play';
                    renderStrokes();
                    return;
                }
                
                isReplaying = true;
                replayBtn.textContent = 'Stop';
                replayStrokeIndex = 0;
                replayPointIndex = 0;
                
                const animate = () => {
                    if (!isReplaying) return;
                    
                    if (replayStrokeIndex >= detectedStrokes.length) {
                        isReplaying = false;
                        replayBtn.textContent = 'Play';
                        return;
                    }
                    
                    const currentStroke = detectedStrokes[replayStrokeIndex];
                    const speed = parseInt(speedSlider.value);
                    
                    if (replayPointIndex < currentStroke.length) {
                        replayPointIndex += Math.max(1, Math.floor(speed / 5));
                        renderStrokes(replayStrokeIndex + 1, replayPointIndex);
                        setTimeout(() => requestAnimationFrame(animate), 20);
                    } else {
                        replayStrokeIndex++;
                        replayPointIndex = 0;
                        requestAnimationFrame(animate);
                    }
                };
                
                animate();
            };

            const exportPDF = async () => {
        try {
            // Check if jsPDF is loaded
            if (!window.jspdf) {
                new Notice('jsPDF library not loaded');
                return;
            }
            
            const { jsPDF } = window.jspdf;
            
            // Create PDF document
            const pdf = new jsPDF({
                orientation: 'portrait',
                unit: 'pt',
                format: 'a4'
            });
            
            const canvas = document.createElement('canvas');
            canvas.width = 595 * 2;
            canvas.height = 842 * 2;
            const ctx = canvas.getContext('2d');
            
            if (!ctx) return;
            
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.scale(2, 2);
            
            const strokeWidth = parseFloat(widthSlider.value);
            const opacity = parseFloat(opacitySlider.value);
            const color = colorPicker.value;
            const smoothness = parseInt(smoothSlider.value);
            
            ctx.strokeStyle = color;
            ctx.lineWidth = strokeWidth;
            ctx.globalAlpha = opacity;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            detectedStrokes.forEach(stroke => {
                if (stroke.length < 2) return;
                const smoothed = this.smoothPoints(stroke, smoothness);
                
                ctx.beginPath();
                ctx.moveTo(smoothed[0][0], smoothed[0][1]);
                for (let i = 1; i < smoothed.length; i++) {
                    ctx.lineTo(smoothed[i][0], smoothed[i][1]);
                }
                ctx.stroke();
            });
            
            // Convert canvas to image and add to PDF
            const imgData = canvas.toDataURL('image/jpeg', 0.95);
            pdf.addImage(imgData, 'JPEG', 0, 0, 595, 842);
            
            // Get PDF as blob and save to vault
            const pdfBlob = pdf.output('blob');
            const arrayBuffer = await pdfBlob.arrayBuffer();
            
            // Save to vault
            const pdfFileName = strokeFileName.replace('_strokes.json', '_rendered.pdf');
            const pdfPath = `${this.settings.pdfFolder}/${pdfFileName}`;
            const normalizedPdfPath = normalizePath(pdfPath);
            
            try {
                const existingPdf = this.app.vault.getAbstractFileByPath(normalizedPdfPath);
                
                if (existingPdf instanceof TFile) {
                    await this.app.vault.modifyBinary(existingPdf, arrayBuffer);
                    new Notice(`Updated: ${pdfFileName}`);
                } else {
                    await this.ensureFolder(this.settings.pdfFolder);
                    await this.app.vault.createBinary(normalizedPdfPath, arrayBuffer);
                    new Notice(`Created: ${pdfFileName}`);
                }
            } catch (error: any) {
                console.error('Failed to save PDF:', error);
                new Notice('Failed to save PDF: ' + error.message);
            }
            
        } catch (error: any) {
            new Notice('PDF export failed: ' + error.message);
        }
    };

            smoothSlider.addEventListener('input', () => renderStrokes());
            widthSlider.addEventListener('input', () => renderStrokes());
            opacitySlider.addEventListener('input', () => renderStrokes());
            colorPicker.addEventListener('input', () => renderStrokes());
            replayBtn.addEventListener('click', startReplay);
            pdfBtn.addEventListener('click', exportPDF);
            
            renderStrokes();
            
            console.log('=== COMPLETE ===');
            
        } catch (error: any) {
            console.error('Error:', error);
            el.createEl('p', { text: 'Failed to load: ' + error.message });
        }
    }

    private smoothPoints(points: number[][], factor: number): number[][] {
        if (points.length < 3 || factor === 0) return points;
        
        const smoothed: number[][] = [];
        for (let i = 0; i < points.length; i++) {
            let sumX = 0, sumY = 0, count = 0;
            for (let j = Math.max(0, i - factor); j <= Math.min(points.length - 1, i + factor); j++) {
                sumX += points[j][0];
                sumY += points[j][1];
                count++;
            }
            smoothed.push([sumX / count, sumY / count, points[i][2]]);
        }
        return smoothed;
    }

    smoothStrokeData(strokeData: any, smoothness: number): number[][][] {
        const strokes: number[][][] = [];
        let currentStroke: number[][] = [];
        for (let i = 0; i < strokeData.length; i++) {
            const point = strokeData[i];
            if (i === 0) {
                currentStroke.push(point);
            } else {
                const prevPoint = strokeData[i - 1];
                const timeDiff = point[2] - prevPoint[2];
                const distance = Math.hypot(point[0] - prevPoint[0], point[1] - prevPoint[1]);
                if (timeDiff > 5 || distance > 100) {
                    if (currentStroke.length > 1) strokes.push(currentStroke);
                    currentStroke = [point];
                } else {
                    currentStroke.push(point);
                }
            }
        }
        if (currentStroke.length > 1) strokes.push(currentStroke);
        if (smoothness === 0) return strokes;
        return strokes.map(stroke => {
            if (stroke.length < 3) return stroke;
            const smoothed: number[][] = [];
            for (let i = 0; i < stroke.length; i++) {
                let sumX = 0, sumY = 0, count = 0;
                for (let j = Math.max(0, i - smoothness); j <= Math.min(stroke.length - 1, i + smoothness); j++) {
                    sumX += stroke[j][0];
                    sumY += stroke[j][1];
                    count++;
                }
                smoothed.push([sumX / count, sumY / count, stroke[i][2]]);
            }
            return smoothed;
        });
    }

    getPenStyle(penId: number): { color: string, width: number, opacity: number } {
        const mapping = this.penMappings[penId];
        if (mapping) {
            const colorDefinitions: { [key: string]: string } = { black: '#000000', white: '#FFFFFF', lightGray: '#C0C0C0', mediumGray: '#808080', darkGray: '#404040', gray: '#808080', red: '#FF0000', green: '#00AA00', blue: '#0000FF', yellow: '#FFD700' };
            const penTypeBaseWidths: { [key: string]: number } = { calligraphy: 3, fountain: 2.5, ballpoint: 2, fineliner: 1.2, pencil: 2.2, highlighter: 18, thinkers: 2 };
            const thicknessMultipliers: { [key: string]: number } = { 'Ultra Fine': 0.5, 'Fine': 0.7, 'Medium': 1.0, 'Medium Bold': 1.3, 'Bold': 1.7 };
            const baseWidth = penTypeBaseWidths[mapping.type] || 2;
            const multiplier = thicknessMultipliers[mapping.thickness] || 1.0;
            return { color: colorDefinitions[mapping.color] || '#000000', width: baseWidth * multiplier, opacity: mapping.opacity || 1 };
        }
        return { color: '#000000', width: 2, opacity: 1 };
    }

    replayStrokes(svg: SVGElement, strokeData: any, smoothness: number) {
        svg.innerHTML = '';
        const smoothedStrokes = this.smoothStrokeData(strokeData, smoothness);
        let strokeIndex = 0;
        let pointIndex = 0;
        const animate = () => {
            if (strokeIndex >= smoothedStrokes.length) return;
            const stroke = smoothedStrokes[strokeIndex];
            if (pointIndex < stroke.length - 1) {
                const p1 = stroke[pointIndex];
                const p2 = stroke[pointIndex + 1];
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                const style = { color: '#000000', width: 3, opacity: 1 };
                line.setAttribute('x1', p1[0].toString());
                line.setAttribute('y1', p1[1].toString());
                line.setAttribute('x2', p2[0].toString());
                line.setAttribute('y2', p2[1].toString());
                line.setAttribute('stroke', style.color);
                line.setAttribute('stroke-width', style.width.toString());
                line.setAttribute('stroke-opacity', style.opacity.toString());
                line.setAttribute('stroke-linecap', 'round');
                svg.appendChild(line);
                pointIndex++;
            } else {
                strokeIndex++;
                pointIndex = 0;
            }
            requestAnimationFrame(animate);
        };
        animate();
    }

    async exportSvgToPdf(svg: SVGElement, strokeData: any, smoothness: number, backgroundColor: string) {
        if (!window.jspdf) {
            new Notice('jsPDF library not loaded');
            return;
        }
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({ orientation: 'portrait', unit: 'pt', format: 'letter' });
        const canvas = document.createElement('canvas');
        canvas.width = 1440 * 2;
        canvas.height = 1920 * 2;
        const ctx = canvas.getContext('2d');
        if (!ctx) return;
        ctx.scale(2, 2);
        ctx.fillStyle = backgroundColor;
        ctx.fillRect(0, 0, 1440, 1920);
        const smoothedStrokes = this.smoothStrokeData(strokeData, smoothness);
        for (const stroke of smoothedStrokes) {
            if (stroke.length < 2) continue;
            const style = this.getPenStyle(stroke[0][2] || 0);
            ctx.save();
            ctx.globalAlpha = style.opacity;
            ctx.strokeStyle = style.color;
            ctx.lineWidth = style.width;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            ctx.moveTo(stroke[0][0], stroke[0][1]);
            for (let i = 1; i < stroke.length; i++) ctx.lineTo(stroke[i][0], stroke[i][1]);
            ctx.stroke();
            ctx.restore();
        }
        const imgData = canvas.toDataURL('image/jpeg', 0.8);
        const pdfWidth = 612;
        const pdfHeight = 792;
        const margin = 36;
        const availWidth = pdfWidth - 2 * margin;
        const availHeight = pdfHeight - 2 * margin;
        const scale = Math.min(availWidth / 1440, availHeight / 1920);
        const scaledWidth = 1440 * scale;
        const scaledHeight = 1920 * scale;
        const x = (pdfWidth - scaledWidth) / 2;
        const y = (pdfHeight - scaledHeight) / 2;
        pdf.addImage(imgData, 'JPEG', x, y, scaledWidth, scaledHeight);
        pdf.save('viwoods-page.pdf');
    }

    exportSvgToPng(svg: SVGElement) {
        const canvas = document.createElement('canvas');
        canvas.width = 1440;
        canvas.height = 1920;
        const ctx = canvas.getContext('2d');
        if (!ctx) return;
        const svgData = new XMLSerializer().serializeToString(svg);
        const img = new Image();
        const blob = new Blob([svgData], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);
        img.onload = () => {
            ctx.drawImage(img, 0, 0);
            canvas.toBlob((pngBlob) => {
                if (pngBlob) {
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(pngBlob);
                    link.download = 'viwoods-page.png';
                    link.click();
                    URL.revokeObjectURL(link.href);
                }
            }, 'image/png');
            URL.revokeObjectURL(url);
        };
        img.src = url;
    }

    async exportCurrentPageToPDF(view: MarkdownView) {
        if (!this.settings.enablePdfExport) {
            new Notice('PDF export is disabled in settings');
            return;
        }
        const file = view.file;
        if (!file) return;
        const cache = this.app.metadataCache.getFileCache(file);
        const frontmatter = cache?.frontmatter;
        if (!frontmatter || !frontmatter.has_strokes) {
            new Notice('This page has no stroke data');
            return;
        }
        const bookName = frontmatter.book;
        const pageNum = frontmatter.page;
        if (!bookName || !pageNum) {
            new Notice('Could not determine page information');
            return;
        }
        const strokeFileName = `${bookName}_page_${String(pageNum).padStart(3, '0')}_strokes.json`;
        const strokePath = `${file.parent?.path}/${this.settings.strokesFolder}/${strokeFileName}`;
        const strokeFile = this.app.vault.getAbstractFileByPath(strokePath);
        if (!(strokeFile instanceof TFile)) {
            new Notice('Stroke data file not found');
            return;
        }
        try {
            const strokeContent = await this.app.vault.read(strokeFile);
            const strokeData = JSON.parse(strokeContent);
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg') as SVGElement;
            svg.setAttribute('viewBox', '0 0 1440 1920');
            await this.exportSvgToPdf(svg, strokeData, this.settings.defaultSmoothness, this.settings.backgroundColor);
            new Notice('PDF exported successfully');
        } catch (error) {
            console.error('Failed to export PDF:', error);
            new Notice('Failed to export PDF');
        }
    }

    async loadSettings() {
        this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    }

    async saveSettings() {
        await this.saveData(this.settings);
    }
}